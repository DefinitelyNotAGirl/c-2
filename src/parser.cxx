/*
 * Created Date: Tuesday July 25th 2023
 * Author: Lilith
 * -----
 * Last Modified: Thursday August 17th 2023 9:04:51 pm
 * Modified By: Lilith (definitelynotagirl115169@gmail.com)
 * -----
 * Copyright (c) 2023-2023 DefinitelyNotAGirl@github
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <codegen.h>
#include <common.h>
#include <compiler.h>
#include <error.h>
#include <execinfo.h>
#include <filesystem>
#include <mangling.h>
#include <miscout.h>
#include <options.h>
#include <rstack.h>
#include <signal.h>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>

std::vector<std::string> DataCode;
std::vector<std::string> RoDataCode;
std::vector<std::string> BssCode;
std::vector<std::string> TextCode;
std::vector<std::string> MiscCode;

std::vector<std::string> includedFiles;

std::vector<line> getLines(std::string fname);

line compLine(std::string text)
{
    line l;
    l.file = "code generated by compiler";
    l.leadingSpaces = 0;
    l.lineNum = 0;
    l.text = text;
    return l;
}

std::string getIndent() {
	scope* sc = currentScope;
	std::string ret;
	while (sc != nullptr) {
        if(sc->t == scopeType::FUNCTION || sc->t == scopeType::CONDITIONAL_BLOCK)
		    ret += "\t";
		sc = sc->parent;
	}
	return ret;
}

function* getFunction(std::string name)
{ 
    scope* sc = currentScope;
    while (sc != nullptr) {
		for (function* i : sc->functions) 
			if (i->name == name) 
                return i;
		sc = sc->parent;
	}
    return nullptr;
}

arch* getArch(std::string name)
{
    for(arch* i : architectures)
        if(i->name == name)
            return i;
    return nullptr;
}

std::string getFunctionExpression(function* f, bool showVariableNames = false) {
	std::string res = f->returnType->name + " " + f->name + "(";
	if (!showVariableNames) {
		for (type* i : f->parameters)
			res += i->name + ",";
	} else {
		for (variable* i : f->vparams)
        {
			res += i->dataType->name + " " + i->name + ",";
        }
	}
	if (res.back() == ',') res.pop_back();
	res += ")";
	return res;
}

std::string getFunctionExpression(std::string name,
								  std::vector<variable*> args) {
	std::string res = name + "(";
	for (variable* i : args)
	{
        //std::cout << "var: " << std::hex << (void*)i << std::endl;
        //std::cout << "var dt: " << std::hex << (void*)(i->dataType) << std::endl;
        res += i->dataType->name + ",";
    }
	if (res.back() == ',') 
        res.pop_back();
	res += ")";
	return res;
}

function* getFunction(std::string name, std::vector<variable*> args) {
	scope* sc = currentScope;
	std::vector<function*> candidates;
	while (sc != nullptr) {
		for (function* i : sc->functions) {
			if (i->name == name) {
				if (i->parameters.size() == args.size()) {
					for (uint64_t II = 0; II < i->parameters.size(); II++){
						if (i->parameters[II] != args[II]->dataType)
							goto notThisFunction;
                    }
					// else
					//     std::cout <<std::hex<<i->parameters[II]<< " != " <<
					//     args[II] << std::endl;
					return i;
				}
			notThisFunction:;
				candidates.push_back(i);
			}
			// else
			//     std::cout << i->name <<" != "<< name << std::endl;
		}
		sc = sc->parent;
	}
	std::cout << "ERROR: cannot find a function to match call \""
			  << getFunctionExpression(name, args)
			  << "\", candidates are: " << std::endl;
	for (function* candidate : candidates)
		std::cout << "    " << getFunctionExpression(candidate) << std::endl;
	return nullptr;
}

variable* getVariable(std::string name) {
	scope* sc = currentScope;
	while (sc != nullptr) {
		for (variable* i : sc->variables)
			if (i->name == name) return i;
            //else std::cout << "\"" << i->name << "\" != \"" << name << "\"" << std::endl;
		sc = sc->parent;
	}
	return nullptr;
}

type* getType(std::string name) {
	for (type* t : types)
		if (t->name == name) return t;
	if (name.back() == '*') {
		// unknown pointer type, create a new type
		type* t = new type;
		t->name = name;
        t->valueType = getType(name.substr(0,name.length()-1));
		t->size = POINTER_SIZE;
        defaultMangler->mangle(t);
		types.push_back(t);
        std::vector<line> lines;
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=("+name+","+defaultUnsignedIntegerType->name+");"));
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=("+name+","+name+");"));
        parse(lines);
		return t;
	}

	if (name.back() == '&' && name[name.length() - 2] != '&') {
		type* t = new type;
		t->name = name;
		t->size = POINTER_SIZE;
        defaultMangler->mangle(t);
		types.push_back(t);
		return t;
	}

	return nullptr;
}

void printToken(token& t)
{
    std::cout << "----- token -----" << std::endl;
    std::cout << "text: " << t.text << std::endl;
    std::cout << "type: " <<std::dec<< t.type << std::endl;
    std::cout << "-----------------" << std::endl;
}

void printLine(line& l)
{
    std::cout << "##### LINE #####" << std::endl;
    std::cout << "line: " << l.text << std::endl;
    std::cout << "indent: " << l.leadingSpaces << " / "<< currentScope->leadingSpace << std::endl;
}

void resetScope()
{
    currentScope = globalScope;
}

ABI* getABI(std::string name)
{
    for(ABI* abi : ABIs)
        if(abi->name == name)
            return abi;
    return nullptr;
}

void updateCurrentScope(scope* sc)
{
    currentScope = sc;
    codeGenUpdateFuction();
}

variable* getImmediateVariable(uint64_t v)
{
    variable* var = new variable;
    var->name = getNewName();
    var->storage = storageType::IMMEDIATE;
    var->immediateValue = v;
    return var;
}

revstack<std::string> scopenames;

uint64_t templateMode = 0;//0: no template, 1: class template, 2: function template, 3: unknown
typeTemplate* __typeTemplate = nullptr;
functionTemplate* __functionTemplate = nullptr;
std::vector<templateArg*> templateArgs;
void parse(std::vector<line> lines) {
    if(lines.size() == 0)
        return;
	uint64_t i = 0;
	while (true) {
		line& L = lines[i];
		if (L.text.empty()) break;
		token t = L.nextToken();
		bool isPrimitiveFunction = 0;
		bool isFunctionOnly		 = 0;
		std::vector<token> attribs;
        for(token& i : currentScope->attribs)
            attribs.push_back(i);
		if(options::ddebug)
		{
            std::cout << "##### LINE #####" << std::endl;
            std::cout << "line: " << L.text << std::endl;
            std::cout << "indent: " << L.leadingSpaces << " / "
					  << currentScope->leadingSpace << std::endl;
        }
		if ((L.leadingSpaces < currentScope->leadingSpace) 
            && currentScope->isIndentBased
            && L.file != "code generated by compiler"
            ){
			scope* ts = currentScope;
			while (true) {
				if (L.leadingSpaces < ts->leadingSpace) {
					if (options::ddebug) std::cout << "body ended: " << ts->name << std::endl;
					if (ts->t == scopeType::FUNCTION || ts->t == scopeType::CONDITIONAL_BLOCK) {
                        //std::cout << "ended body: " << ts->func->symbol << std::endl;
                        //std::cout << "scope: " << ts->name << std::endl;
                        //std::cout << "blocks: " << ts->extraCodeBlocks.size() << std::endl;
                        if(ts->templateMode)
                        {
                            std::cout << "template complete" << std::endl;
                            templateArgs.clear();
                            __typeTemplate = nullptr;
                            __functionTemplate = nullptr;
                            templateMode = 0;
                        }
                        if(ts->t == scopeType::FUNCTION)
                        {
                            std::vector<std::string> lines;
						    ts->func->abi->genProlouge(lines, ts);
						    for (std::string& i : ts->func->code)
						    	lines.push_back(i);
						    ts->func->abi->genEpilouge(lines, ts);
                            for(std::vector<std::string>* block : ts->extraCodeBlocks)
                                for(std::string& i : *block)
                                    lines.push_back(i);
						    for (std::string& i : lines)
						    	TextCode.push_back(i);
						    mOUT(moFunctionID, ts->func);
                        }
                        else if(ts->t == scopeType::CONDITIONAL_BLOCK)
                        {
                            jump(ts->func,ts->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(ts->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry");
                            for(std::vector<std::string>* block : ts->extraCodeBlocks)
                                ts->parent->extraCodeBlocks.push_back(block);
                        }
					} else if (ts->t == scopeType::CLASS) {
                        std::cout << "ended class body: " << ts->cl->mangledName << std::endl;
						ts->cl->incomplete = false;
						mOUT(moClassID, ts->cl);
					} else if (ts->t == scopeType::NAMESPACE) {
                        //std::cout << "ended namespace body: " << ts->name << std::endl;
					}
                    
                    //clean up memory
                    switch(ts->t)
                    {
                        case(scopeType::CONDITIONAL_BLOCK):
                            delete ts;
                            break;
                    }
					ts = ts->parent;
				} else {
					break;
				}
				if (ts == nullptr) {
					std::cout << "indentation error! (2)" << std::endl;
					break;
				}
			}
			updateCurrentScope(ts);
		} else if ((L.leadingSpaces > currentScope->leadingSpace) &&
				   currentScope->isIndentBased) {
			//std::cout << "indentation error! (1)" << std::endl;
		}
        if(t.text != "if(" && t.text != "else")
        {
            if(currentScope->reentrySymbol != "")
            {
                placeSymbol(currentScope->func,currentScope->reentrySymbol);
                currentScope->reentrySymbol = "";
            }
        }
        if(currentScope->templateMode)
        {
            switch(templateMode)
            {
                case(1):
                    __typeTemplate->code.push_back(L);
                    goto ENDLINE;
                    break;
                default:
                    errorCompilerBug;
            }
        }
		switch (t.type) {
			case (5): // directive
                if (t.text == "#cum") {
                    goto ENDPARSER;
				} else if (t.text == "#include") {
                    if(options::ddebug)
                        std::cout << "include..." << std::endl;
					t = L.nextToken();
					switch (t.type) {
						case (6):{ // default width string literal
							// std::cout << "including file: " << t.text <<
							// std::endl;
                            std::string inc = t.text;
                            if (std::filesystem::exists(inc)) {
								parse(getLines(inc));
                                resetScope();
                                includedFiles.push_back(inc);
							}
                            else
                                error::noSuchFile(t);
							break;
                        }
						case (34):
                            t = L.nextToken();
							//std::string fname =
							//	t.text.substr(1, t.text.length() - 2);
                            std::string fname = t.text;
							// std::cout << "sys include: " << fname <<
							// std::endl;
                            std::string inc;
							for (std::string i : includeDirs) {
								inc = i + "/" + fname;
								if (std::filesystem::exists(inc)) {
									parse(getLines(inc));
                                    resetScope();
                                    includedFiles.push_back(inc);
									goto sysIncludeSuccess;
								}
								inc += ".h2";
								if (std::filesystem::exists(inc)) {
									parse(getLines(inc));
                                    resetScope();
                                    includedFiles.push_back(inc);
									goto sysIncludeSuccess;
								}
							}
							error::noSuchFile(t);
						    sysIncludeSuccess:;
                            if(options::ddebug)
                                std::cout << "included file: " << inc << std::endl;
						    break;
					}
				} else if (t.text == "#pragma") {
					t = L.nextToken();
					if (t.text == "push") {
						pragma::push();
					} else if (t.text == "pop") {
						pragma::pop();
					} else if (t.text == "warning") {
						t = L.nextToken();
						if (t.text == "enable") {
							t = L.nextToken();
							enableWarningSet(t.text);
						} else if (t.text == "disable") {
							t = L.nextToken();
							disableWarningSet(t.text);
						}
					} else if (t.text == "cpl") {
						t			  = L.nextToken();
						options::fcpl = atoi(t.text.c_str());
                    } else if (t.text == "ABI") {
						t			  = L.nextToken();
						ABI* abi = getABI(t.text);
                        if(abi == nullptr)
                        {
                            error::noSuchABI(t);
                        }
                        else
                            defaultABI = abi;
					} else if(t.text == "once") {
                        bool found = false;
                        for(std::string& i : includedFiles)
                        {
                            if(i == L.file)
                            {
                                found = true;
                                break;
                            }
                        }
                        if(found)
                        {
                            //std::cout << "parser stopped by \"#pragma once\"" << std::endl;
                            goto ENDPARSER;
                        }
                    } else if(t.text == "stack-pointer") {
                        t = L.nextToken();
                        StackPointer = registerID(t.text);
                    }
				} else if (t.text == "#autodecl") {
					t = L.nextToken();

					if (t.text == "integer") {
						// name
						t				 = L.nextToken();
						std::string name = t.text;
						// size
						t			  = L.nextToken();
						uint64_t size = std::stoi(t.text);
						std::vector<line> gLines;

						line l;
						l	   = L;
						l.tpos = 0;
						if (getType(name) == nullptr) {
							switch (size) {
								case (0):
									l.text = L.restText() + " class " + name +
											 " extends primitive0;";
									gLines.push_back(l);
									break;
								case (1):
									l.text = L.restText() + " class " + name +
											 " extends primitive8;";
									gLines.push_back(l);
									break;
								case (2):
									l.text = L.restText() + " class " + name +
											 " extends primitive16;";
									gLines.push_back(l);
									break;
								case (4):
									l.text = L.restText() + " class " + name +
											 " extends primitive32;";
									gLines.push_back(l);
									break;
								case (8):
									l.text = L.restText() + " class " + name +
											 " extends primitive64;";
									gLines.push_back(l);
									break;
							}
						}
						if (size > 0) {
                            if(defaultUnsignedIntegerType != nullptr){
                            if(defaultUnsignedIntegerType->name != name){
                                l.text = L.restText() + "primitiveAssign primitiveInPlace void operator=(" + name + "," + defaultUnsignedIntegerType->name + ");";
						    	gLines.push_back(l);
                            }}

							l.text = L.restText() + "primitiveMul " + name +
									 " operator*(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + "primitiveDiv " + name +
									 " operator/(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + "primitiveAdd " + name +
									 " operator+(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + "primitiveSub " + name +
									 " operator-(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + "primitiveMod " + name +
									 " operator%(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 "primitiveMul primitiveInPlace void "
									 "operator*=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 "primitiveDiv primitiveInPlace void "
									 "operator/=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 "primitiveAdd primitiveInPlace void "
									 "operator+=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 "primitiveSub primitiveInPlace void "
									 "operator-=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 "primitiveMod primitiveInPlace void "
									 "operator%=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +"primitiveEqual "+defaultBooleanType->name+" operator==(" + name +"," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +"primitiveGreater "+defaultBooleanType->name+" operator>(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +"primitiveGreaterEqual "+defaultBooleanType->name+" operator>=(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +"primitiveLessEqual "+defaultBooleanType->name+" operator<=(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +"primitiveLess "+defaultBooleanType->name+" operator<(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveAssign primitiveInPlace void "
									 "operator=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveInc primitiveInPlace void "
									 "operator++(" +
									 name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveDec primitiveInPlace void "
									 "operator--(" +
									 name + ");";
							gLines.push_back(l);
						}
						if (gLines.size() > 0) parse(gLines);
					}
				} else if (t.text == "#outcom") {
                    std::string comment = L.restText();
                    putComment(comment);
                }
				break;
            case (26):
			case (25):
			case (22):
			case (21):
			case (20):
            case (30):
			collectAttributes:;
				while (t.type >= 20 && t.type < 31) {
                    if(t.type == 30)
                    {
                        t = L.nextToken();
                        std::string text = "("+t.text;
                        t = L.nextToken();
                        if(t.type == 31)
                            text+=")";
                        else
                        {
                            std::cout << ":skull:" << std::endl;
                            goto ERRORENDLINE;
                        }
                        t.text = text;
                    }
					attribs.push_back(t);
					t = L.nextToken();
				}
				// std::cout << "attributes: ";
				// for(token& a : attribs)
				//     std::cout << a.text << " ";
				// std::cout << std::endl;
			case (8): // keyword
				if (t.type == 8) {
					if (t.text == "enum") {
						t = L.nextToken();
						switch (t.type) {
							case (9): {
								// id redefinition error
								break;
							}
							case (1): {
								type* ntype		  = new type;
								mangler* mangling = defaultMangler;
								ntype->name		  = t.text;
								ntype->size		  = 8;

								for (token& attr : attribs) {
									if (attr.text == "nodoc")
										ntype->nodoc = true;
									else if (attr.text == "deprecated")
										ntype->deprecated = true;
									else if (attr.text == "export")
										ntype->doExport = true;
									else if (attr.text.substr(
												 0, strlen("mangling-")) ==
											 "mangling-") {
										std::string manglerName =
											attr.text.substr(
												strlen("mangling-"),
												attr.text.length());
										mangling = getMangler(manglerName);
										if (mangling == nullptr) {
											std::cout << "ERROR: mangler \""
													  << manglerName
													  << "\" does not exist!"
													  << std::endl;
										}
									} else {
										error::invalidClassAttribute(attr);
										goto ERRORENDLINE;
									}
								}
								if (ntype->name.back() == ':')
									ntype->name.pop_back();
								mangling->mangle(ntype);
								if (L.text.back() == ':') {
									// indent based body
									scope* sc  = new scope;
									sc->parent = currentScope;
									sc->name = currentScope->name + CPE2_SYMBOL_SCOPE_SEP +ntype->mangledName;
									sc->leadingSpace =
										L.leadingSpaces + tabLength;
									sc->isIndentBased = true;
									sc->t			  = scopeType::ENUM;
									sc->cl			  = ntype;
									updateCurrentScope(sc);
									if (options::ddebug)
										std::cout << "enum body started: " << ntype->name << std::endl;
								} else {
									mOUT(moClassID, ntype);
								}
								types.push_back(ntype);
								break;
							}
						}
					} else if (t.text == "class") {
						t = L.nextToken();
						switch (t.type) {
							case (9): {
								// class redefinition error
                                error::expectedNewUnique(t);
								break;
							}
							case (1): {
								type* ntype		  = new type;
								mangler* mangling = defaultMangler;
								ntype->name		  = t.text;
								ntype->size		  = 0;
								t				  = L.nextToken();
                                token f = t;
								switch (t.type) {
									case (40):
										goto collectInheritance;
									case (8):
										if (t.text == "extends") {
										collectInheritance:;
											// collect types to inherit from
                                            int64_t startOffset = 0;
											t = L.nextToken();
                                            if(t.type == 0)
                                            {
                                                t = f;
                                                goto noMoreInheritance;
                                            }
											while (t.type == 9 ||
												   t.type == 12) {
												if (t.type == 12) {
													if (t.text == "primitive64") {
														ntype->size += 8;
														startOffset += 8;
													} else if (t.text == "primitive32") {
														ntype->size += 4;
														startOffset += 4;
													} else if (t.text == "primitive16") {
														ntype->size += 2;
														startOffset += 2;
													} else if (t.text == "primitive8") {
														ntype->size += 1;
														startOffset += 1;
													} else if (t.text == "primitiveFloat64") {
														ntype->size += 8;
														startOffset += 8;
													} else if (t.text == "primitiveFloat32") {
														ntype->size += 4;
														startOffset += 4;
													}
												} else if (t.type == 9) {
													type* it = getType(t.text);
													if (it == nullptr) {
														error::noSuchType(t);
														delete ntype;
														goto ERRORENDLINE;
													}
													for (variable m :
														 it->members) {
														m.offset += startOffset;
														ntype->members
															.push_back(m);
													}
													startOffset += it->size;
												}
												t = L.nextToken();
                                                switch(t.type)
                                                {
                                                    case(40):
                                                    case(41):
                                                        goto noMoreInheritance;
                                                    case(42):
                                                        break;
                                                    default:
                                                        error::noSuchType(t);
                                                        delete ntype;
                                                }
                                                t = L.nextToken();
											}
                                            noMoreInheritance:;
											ntype->size = startOffset;
										}
										break;
								}
								for (token& attr : attribs) {
									if (attr.text == "nodoc")
										ntype->nodoc = true;
									else if (attr.text == "iteratable")
										ntype->iteratable = true;
									else if (attr.text == "deprecated")
										ntype->deprecated = true;
									else if (attr.text == "export")
										ntype->doExport = true;
                                    else if (attr.text == "defaultSignedInt")
										defaultSignedIntegerType = ntype;
                                    else if (attr.text == "defaultUnsignedInt")
										defaultUnsignedIntegerType = ntype;
                                    else if (attr.text == "defaultBool")
										defaultBooleanType = ntype;
                                    else if (attr.text == "defaultFloat")
										defaultFloatType = ntype;
                                    else if (attr.text == "defaultChar")
										defaultCharType = ntype;
                                    else if (attr.text == "defaultWchar")
										defaultWcharType = ntype;
									else if (attr.text.substr(
												 0, strlen("mangling-")) ==
											 "mangling-") {
										std::string manglerName =
											attr.text.substr(
												strlen("mangling-"),
												attr.text.length());
										mangling = getMangler(manglerName);
										if (mangling == nullptr) {
											std::cout << "ERROR: mangler \""
													  << manglerName
													  << "\" does not exist!"
													  << std::endl;
										}
									} else {
										error::invalidClassAttribute(attr);
										goto ERRORENDLINE;
									}
								}
								mangling->mangle(ntype);
								if (t.type == 40) {
									// indent based body
                                    std::cout << "harder daddy!" << std::endl;
									ntype->incomplete = true;
									scope* sc		  = new scope;
									sc->parent		  = currentScope;
									sc->name = currentScope->name + CPE2_SYMBOL_SCOPE_SEP +ntype->mangledName;
									sc->leadingSpace = L.leadingSpaces + tabLength;
									sc->isIndentBased = true;
									sc->t			  = scopeType::CLASS;
									sc->cl			  = ntype;
                                    sc->templateMode = true;
                                    __typeTemplate = new typeTemplate;
                                    __typeTemplate->tArgs = templateArgs;
                                    __typeTemplate->name = ntype->name;
                                    if(templateMode == 3)templateMode = 1;
									updateCurrentScope(sc);
									//if (options::ddebug)
										std::cout << "class body started: " << ntype->name << std::endl;
								} else if (t.type == 41) {
									mOUT(moClassID, ntype);
								} else {
                                    printToken(t);
                                    errorCompilerBug;
                                }
                                if(templateMode == 0)
								    types.push_back(ntype);
                                else
                                    std::cout << "template mode: " << templateMode << std::endl;
                                std::cout << "most recent type: " << types.back()->name << std::endl;
								break;
							}
							default:
								// error unexpected token
                                error::expectedNewUnique(t);
								break;
						}
					} else if (t.text == "litop") {
                        //0x492057414E542042494720434F434B
						t = L.nextToken();
						switch (t.type) {
							case (1): {
								litop* lop = new litop;
								lop->name  = t.text;
								t		   = L.nextToken();
								switch (t.type) {
									case (13):
										if (t.text == "add")
											lop->op = shortOP::ADD;
										else if (t.text == "sub")
											lop->op = shortOP::SUB;
										else if (t.text == "mul")
											lop->op = shortOP::MUL;
										else if (t.text == "div")
											lop->op = shortOP::DIV;
										else if (t.text == "cast")
											lop->op = shortOP::CAST;

										if (lop->op == shortOP::CAST) {
											t = L.nextToken();
											switch (t.type) {
												case (9): {
													type* ct = getType(t.text);
													if (ct == nullptr) {
														error::noSuchType(t);
														delete lop;
														goto ERRORENDLINE;
													}
													break;
												}
												default:
													error::noSuchType(t);
													delete lop;
													goto ERRORENDLINE;
											}
										} else {
											t = L.nextToken();
											lop->value =
												resolve(t)->immediateValue;
											litops.push_back(lop);
										}
										break;
									default:
										error::expectedShortop(t);
								}
								break;
							}
							default: {
								error::expectedNewUnique(t);
							}
						}
					} else if (t.text == "namespace") {
						std::vector<std::string> nsp;
						t = L.nextToken();
                        bool wasColon = false;
                        while(true)
                        {
                            if(t.type == 40)
                                if(wasColon)
                                    wasColon = false;
                                else
                                {
                                    wasColon = true;
                                    break;
                                }
                            else if(t.type == 1)
                                nsp.push_back(t.text);
                            t = L.nextToken();
                        }

						std::string symb = currentScope->name;
						scope* sco		 = nullptr;
						for (std::string ns : nsp) {
							scope* sc = new scope;
							sc->t	  = scopeType::NAMESPACE;
							if (!symb.empty()) symb += CPE2_SYMBOL_SCOPE_SEP;
							symb += ns;
							sc->name   = symb;
							sc->parent = currentScope;
							if (sco) sc->lparent = sco;
							else sc->lparent = currentScope;
							sco = sc;
                            if(options::ddebug)
							    std::cout << "declared namespace: " << symb<< std::endl;
						}
						if(wasColon) 
                        {
                            sco->leadingSpace = L.leadingSpaces + tabLength;
                            updateCurrentScope(sco);
                        }
                        sco->attribs = attribs;
					} else if (t.text == "return") {
                        if(options::ddebug)std::cout << "return" << std::endl;
                        t = L.nextToken();
                        variable* retVal = resolve(t);
                        variable* ret = new variable;
                        ret->storage = storageType::REGISTER;
                        ret->reg = currentScope->func->abi->integerReturn;
                        ret->dataType = currentScope->func->returnType;
                        mov(retVal,ret);
                        jump(currentScope->func,currentScope->func->symbol+CPE2_SYMBOL_SCOPE_SEP+"epilogue");
                    } else if (t.text == "if") {
                        if(options::ddebug)std::cout << "if" << std::endl;
                        scope* sc = new scope;
                        sc->leadingSpace=currentScope->leadingSpace+tabLength;
                        sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"if"+std::to_string(currentScope->ifCounter++);
                        sc->parent = currentScope;
                        sc->isIndentBased = true;
                        sc->t = scopeType::CONDITIONAL_BLOCK;
                        sc->fstore = new functionStorage;
                        sc->func = new function;
                        sc->parent->conditionalCounter++;
                        *(sc->func) = *(currentScope->func);
                        *(sc->fstore) = *(currentScope->fstore);
                        sc->func->code = std::vector<std::string>();
                        currentScope->reentrySymbol = sc->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                        sc->extraCodeBlocks.push_back(&sc->func->code);
                        //generate conditional jump code
                        line cl = L;
                        cl.text = "";
                        cl.tpos = 0;
                        token cond;
                        if(t.type == 30)
                        {
                            t = L.nextToken();
                            cond = t;
                            while(cond.type != 31)//while != )
                            {
                                //std::cout << "type: " << t.type << std::endl;
                                //std::cout << "text: " << 
                                cond = L.nextToken();
                                cl.text += cond.text;
                            }
                            cl.tpos = 0;
                        }
                        else
                        {
                            cond = t;
                            while(cond.type != 40)//while != :
                            {
                                cond = L.nextToken();
                                if(cond.type != 40){
                                    cl.text += cond.text;
                                }
                            }
                            cl.tpos = 0;
                        }
                        
                        cond = cl.nextToken();
                        std::cout << "condition: " << cond.text << std::endl;
                        variable* condition = resolve(cond);
                        variable* __false__ = getImmediateVariable(0);
                        cmp(__false__,condition);
                        jne(sc->name);
                        //set return symbol
                        updateCurrentScope(sc);
                        placeSymbol(sc->func,sc->name);
                    } else if (t.text == "else") {
                        t = L.nextToken();
                        if(t.text == "if")
                        {
                            if(options::ddebug)std::cout << "else if" << std::endl;
                            scope* sc = new scope;
                            sc->leadingSpace=currentScope->leadingSpace+tabLength;
                            sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"elseif"+std::to_string(currentScope->elseIfCounter++);
                            sc->parent = currentScope;
                            sc->isIndentBased = true;
                            sc->t = scopeType::CONDITIONAL_BLOCK;
                            sc->fstore = new functionStorage;
                            sc->func = new function;
                            *(sc->func) = *(currentScope->func);
                            *(sc->fstore) = *(currentScope->fstore);
                            sc->func->code = std::vector<std::string>();
                            sc->extraCodeBlocks.push_back(&sc->func->code);
                            currentScope->reentrySymbol = sc->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                            //generate conditional jump code
                            line cl = L;
                            cl.text = "";
                            cl.tpos = 0;
                            token cond;
                            if(t.type == 30)
                            {
                                t = L.nextToken();
                                cond = t;
                                while(cond.type != 31)//while != )
                                {
                                    //std::cout << "type: " << t.type << std::endl;
                                    //std::cout << "text: " << 
                                    cond = L.nextToken();
                                    cl.text += cond.text;
                                }
                                cl.tpos = 0;
                            }
                            else
                            {
                                cond = t;
                                while(cond.type != 40)//while != :
                                {
                                    cond = L.nextToken();
                                    if(cond.type != 40){
                                        cl.text += cond.text;
                                    }
                                }
                                cl.tpos = 0;
                            }

                            cond = cl.nextToken();
                            std::cout << "condition: " << cond.text << std::endl;
                            variable* condition = resolve(cond);
                            variable* __false__ = getImmediateVariable(0);
                            cmp(__false__,condition);
                            jne(sc->name);
                            //set return symbol
                            updateCurrentScope(sc);
                            placeSymbol(sc->func,sc->name);
                        }
                        else
                        {
                            if(options::ddebug)std::cout << "else" << std::endl;
                            scope* sc = new scope;
                            sc->leadingSpace=currentScope->leadingSpace+tabLength;
                            sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"else"+std::to_string(currentScope->elseCounter++);
                            sc->parent = currentScope;
                            sc->isIndentBased = true;
                            sc->t = scopeType::CONDITIONAL_BLOCK;
                            sc->fstore = new functionStorage;
                            sc->func = new function;
                            *(sc->func) = *(currentScope->func);
                            *(sc->fstore) = *(currentScope->fstore);
                            sc->func->code = std::vector<std::string>();
                            sc->extraCodeBlocks.push_back(&sc->func->code);
                            currentScope->reentrySymbol = sc->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                            //set return symbol
                            updateCurrentScope(sc);
                            placeSymbol(sc->func,sc->name);
                        }
                    } else if (t.text == "template") {
                        t = L.nextToken();
                        if(t.type == 34)
                        {
                            templateArgs.clear();
                            while (true) {
								t = L.nextToken();
                                templateArg* ta = new templateArg;
								switch (t.type) {
									case (50):
										if(t.text == "typename")
                                            ta->Type = 2;
                                        else if(t.text == "integer")
                                            ta->Type = 1;
                                        else if(t.text == "float")
                                            ta->Type = 3;
                                        else
                                        {
                                            error::expectedTemplateArg(t);
                                            goto ERRORENDLINE;
                                        }
										break;
                                    case(35):
                                        goto TEMPLATENOARGS;
                                        break;
									default:
										error::expectedTemplateArg(t);
										goto ERRORENDLINE;
								}
                                t = L.nextToken();
                                switch (t.type) {
                                    case(1):
                                        ta->name = t.text;
                                        t = L.nextToken();
                                        break;
                                    case(35):
                                        goto TEMPLATENOARGS;
                                        break;
									default:
										error::expectedNewUnique(t);
										goto ERRORENDLINE;
								}
                                templateArgs.push_back(ta);
							}
                            TEMPLATENOARGS:;
                            templateMode = 3;
                        }
                        else
                        {
                            //syntax error, no < after template keyword
                        }
                    }
					break;
				}
			case (9):
				switch (t.type) {
					case (9): {
						// function or variable declaration
						type* it = getType(t.text);
						if (it == nullptr) {
							error::noSuchType(t);
							goto ERRORENDLINE;
						}
						t				 = L.nextToken();
						std::string name = t.text;
						bool isFunction	 = false;
                        t = L.nextToken();
                        if(t.type == 30)
                        {
                            //t = L.nextToken();
                            isFunction = true;
                        }
						if (isFunction) {
							mangler* mangling	  = defaultMangler;
							bool isStatic		  = false;
							bool isInline		  = false;
							bool isExtern		  = false;
							bool isConst		  = false;
							bool isNoop			  = false;
                            bool isNoReturn		  = false;
							bool doExport		  = false;
							bool nodoc			  = false;
							bool isDeprecated	  = false;
							bool isPrimitive	  = false;
							bool primitiveFloat	  = false;
							bool primitiveInPlace = false;
							primitiveOP op		  = primitiveOP::invalid;
							uint8_t access		  = 0;
							ABI* abi = defaultABI;
							for (token& attr : attribs) {
								if (attr.text == "static") isStatic = true;
								else if (attr.text == "public") access = 0;
								else if (attr.text == "protected") access = 1;
								else if (attr.text == "private") access = 2;
								else if (attr.text == "inline") isInline = true;
								else if (attr.text == "const") isConst = true;
								else if (attr.text == "extern") isExtern = true;
								else if (attr.text == "noop") isNoop = true;
                                else if (attr.text == "noreturn") isNoReturn = true;
								else if (attr.text == "nodoc") nodoc = true;
								else if (attr.text == "export") doExport = true;
								else if (attr.text == "deprecated")
									isDeprecated = true;
								else if (attr.text.substr(
											   0, strlen("ABI-")) ==
										   "ABI-") {
									std::string ABIName =
										attr.text.substr(strlen("ABI-"),
														 attr.text.length());
									abi = getABI(ABIName);
									if (abi == nullptr) {
										std::cout << "ERROR: ABI \""
												  << ABIName
												  << "\" does not exist!"
												  << std::endl;
									}
								} else if (attr.text.substr(
											   0, strlen("mangling-")) ==
										   "mangling-") {
									std::string manglerName =
										attr.text.substr(strlen("mangling-"),
														 attr.text.length());
									mangling = getMangler(manglerName);
									if (mangling == nullptr) {
										std::cout << "ERROR: mangler \""
												  << manglerName
												  << "\" does not exist!"
												  << std::endl;
									}
								} else if (attr.text.substr(
											   0, strlen("primitive")) ==
										   "primitive") {
									isPrimitive = true;
									// primitives
									if (attr.text == "primitiveInPlace")
										primitiveInPlace = true;
									else if (attr.text == "primitiveFloat")
										primitiveFloat = true;
									else if (attr.text == "primitiveAdd")
										op = primitiveOP::add;
									else if (attr.text == "primitiveSub")
										op = primitiveOP::sub;
									else if (attr.text == "primitiveMul")
										op = primitiveOP::mul;
									else if (attr.text == "primitiveDiv")
										op = primitiveOP::div;
									else if (attr.text == "primitiveMod")
										op = primitiveOP::mod;
									else if (attr.text == "primitiveEqual")
										op = primitiveOP::equal;
									else if (attr.text == "primitiveNotEqual")
										op = primitiveOP::NotEqual;
									else if (attr.text == "primitiveGreater")
										op = primitiveOP::Greater;
									else if (attr.text ==
											 "primitiveGreaterEqual")
										op = primitiveOP::GreaterEqual;
									else if (attr.text == "primitiveLess")
										op = primitiveOP::Less;
									else if (attr.text == "primitiveLessEqual")
										op = primitiveOP::LessEqual;
									else if (attr.text == "primitiveAnd")
										op = primitiveOP::_and;
									else if (attr.text == "primitiveXor")
										op = primitiveOP::_xor;
									else if (attr.text == "primitiveOr")
										op = primitiveOP::_or;
									else if (attr.text == "primitiveNot")
										op = primitiveOP::Not;
									else if (attr.text == "primitiveInc")
										op = primitiveOP::Inc;
									else if (attr.text == "primitiveDec")
										op = primitiveOP::Dec;
									else if (attr.text == "primitiveAssign")
										op = primitiveOP::assign;
								} else {
									error::invalidFunctionAttribute(attr);
									goto ERRORENDLINE;
								}
							}
							type* returnType = nullptr;
							std::vector<type*> paramTypes;
							std::vector<variable*> arguments;
							bool hasMoreParams = true;
							if (currentScope->t == scopeType::CLASS) {
								type* refType = getType(currentScope->cl->name + "&");
								paramTypes.push_back(refType);
								variable* targ = new variable;
								targ->dataType = refType;
								targ->name	   = "this";
								arguments.push_back(targ);
							}
                            t = L.nextToken();
							while (true) {
                                variable* arg = new variable;
                                switch(t.type)
                                {
                                    case(42):
                                        t = L.nextToken();
                                        break;
                                    case(31):
                                        goto FUNCTIONNOARGS;
                                }
								switch (t.type) {
									case (9):
										returnType = getType(t.text);
										if (returnType->incomplete) {
											error::incompleteType(t);
											goto ERRORENDLINE;
										}
                                        arg->dataType = returnType;
										break;
                                    case(31):
                                        paramTypes.push_back(returnType);
                                        arguments.push_back(arg);
                                        goto FUNCTIONNOARGS;
                                        break;
									default:
										error::expectedTypename(t);
										goto ERRORENDLINE;
								}
                                t = L.nextToken();
                                switch (t.type) {
                                    case(1):
                                        arg->name = t.text;
                                        t = L.nextToken();
                                        break;
                                    case(31):
                                        paramTypes.push_back(returnType);
                                        arguments.push_back(arg);
                                        goto FUNCTIONNOARGS;
                                        break;
                                    case(42):
                                        arg->name = getNewName();
                                        t = L.nextToken();
                                        break;
									default:
										error::expectedNewUnique(t);
										goto ERRORENDLINE;
								}
                                paramTypes.push_back(returnType);
                                arguments.push_back(arg);
							}
                            FUNCTIONNOARGS:;
							returnType = it;
							if (returnType->incomplete) {
								error::incompleteType(t);
								//goto ERRORENDLINE;
							}
							function* func		   = new function;
							func->name			   = name;
							func->parameters	   = paramTypes;
							func->vparams		   = arguments;
							func->returnType	   = returnType;
							func->fstore		   = new functionStorage;
							func->isDeprecated	   = isDeprecated;
							func->isPrimitive	   = isPrimitive;
							func->primitiveFloat   = primitiveFloat;
							func->primitiveInPlace = primitiveInPlace;
							func->op			   = op;
                            func->noReturn         = isNoReturn;
							func->noDoc			   = nodoc;
							func->doExport		   = doExport;
                            func->abi = abi;
                            mangling->mangle(func);
							currentScope->functions.push_back(func);
                            if(options::ddebug)
							    std::cout << "declared function: "<< getFunctionExpression(func, true) << std::endl;
                            t = L.nextToken();
							if (t.type == 40) {
								// indent based body
								scope* sc		  = new scope;
								sc->parent		  = currentScope;
								sc->name		  = func->symbol;
								sc->leadingSpace  = L.leadingSpaces + tabLength;
								sc->isIndentBased = true;
								sc->t			  = scopeType::FUNCTION;
								sc->fstore		  = func->fstore;
								sc->func		  = func;

								// declare variables for arguments
                                func->abi->setArgStorages(func,arguments);
								for (variable* arg : arguments) {
                                    sc->variables.push_back(arg);
									if (options::asmVerbose >= 2 || options::ddebug) {
										std::string comment = "    # " +
															  arg->name +
															  " is stored ";
										if (arg->storage ==
											storageType::MEMORY) {
											if (arg->offset < 0)
												comment += "at "+registerNAME(arg->reg);
											else 
                                                comment += "at "+registerNAME(arg->reg)+"+";
											comment += std::to_string(
												(int64_t)arg->offset);
										} else if (arg->storage ==
												   storageType::REGISTER) {
											comment +=
												"in " + registerNAME(arg->reg);
										} else if (arg->storage ==
												   storageType::
													   MEMORY_ABSOLUTE) {
											std::stringstream stream;
											stream << std::hex
												   << (int64_t)arg->offset;
											comment += "at 0x" + stream.str();
										}
                                        if(options::asmVerbose >= 2)
                                            sc->func->code.push_back(comment);
                                        if(options::ddebug)
                                            std::cout << comment << std::endl;
									}
								}
								updateCurrentScope(sc);
								if (options::ddebug)
									std::cout << "body started" << std::endl;
                                if(!isStatic)
								    MiscCode.push_back(".global " + func->symbol);
							} else if (t.type == 41) {
								// function declaration
								if (!isPrimitive)
									MiscCode.push_back(".extern " +
													   func->symbol);
								mOUT(1, func);
							} else {
                                errorCompilerBug;
                            }
						} else {
							variable* var	  = new variable;
							var->dataType	  = it;
							mangler* mangling = defaultMangler;
							bool isStatic	  = false;
							bool isExtern	  = false;
							bool isConst	  = false;
							bool isVolatile	  = false;
							bool noalloc	  = false;
							uint8_t access	  = 0;
							for (token& attr : attribs) {
								if (attr.text[0] == '(' &&
									attr.text.back() == ')') {
									// storage attribute
									if (isdigit(attr.text[1])) {
										// absolute memory address
										token blub = t;
										blub.text  = attr.text.substr(
											 1, attr.text.size() - 2);
										uint64_t addr =
											resolve(blub)->immediateValue;
										var->storage =
											storageType::MEMORY_ABSOLUTE;
										var->offset = addr;
									} else if (attr.text[1] == '+' ||
											   attr.text[1] == '-') {
										// address relative to SP
										token blub = t;
										blub.text  = attr.text.substr(
											 1, attr.text.size() - 2);
										uint64_t offset =
											resolve(blub)->immediateValue;
										var->storage = storageType::MEMORY;
										var->offset	 = offset;
                                        var->reg = StackPointer;
									} else {
										// register
										std::string rname = attr.text.substr(
											1, attr.text.size() - 2);
										__register__ reg = registerID(rname);
										if (reg == __register__::invalid)
											std::cout
												<< "invalid register name: "
												<< rname << std::endl;
										uint64_t rsize =
											BITMASK_REGISTER_SIZE & (uint64_t)reg;
                                        rsize>>=24;
										if (rsize < it->size) {
											std::cout
												<< "ERROR: register \"" << rname
												<< "\" is too small to fit "
												   "variable of type \""
												<< it->name << "\"!"
												<< std::endl;
										}

										var->storage = storageType::REGISTER;
										var->reg	 = reg;
									}
								} else if (attr.text.substr(
											   0, strlen("mangling-")) ==
										   "mangling-") {
									std::string manglerName =
										attr.text.substr(strlen("mangling-"),
														 attr.text.length());
									mangling = getMangler(manglerName);
									if (mangling == nullptr) {
										std::cout << "ERROR: mangler \""
												  << manglerName
												  << "\" does not exist!"
												  << std::endl;
									}
								} else if (attr.text == "static")
									isStatic = true;
								else if (attr.text == "export")
									var->doExport = true;
								else if (attr.text == "public") access = 0;
								else if (attr.text == "protected") access = 1;
								else if (attr.text == "private") access = 2;
								else if (attr.text == "const") isConst = true;
								else if (attr.text == "extern") isExtern = true;
								else if (attr.text == "noalloc") noalloc = true;
								else if (attr.text == "volatile")
									isVolatile = true;
								else {
									error::invalidVariableAttribute(attr);
									goto ERRORENDLINE;
								}
							}
							if (var->storage == storageType::INVALID) {
								// auto storage
                                var->usedAutoStorage = true;
								if (currentScope->t == scopeType::FUNCTION)
									currentScope->fstore->setStorage(currentScope->func,var);
								else if (currentScope->t == scopeType::CLASS) {
									var->offset	 = currentScope->cl->size;
									var->storage = storageType::MEMORY;
								}
							}
							var->name	= name;
							var->access = access;
							mangling->mangle(var);
							if (options::asmVerbose >= 2 &&
								currentScope->t == scopeType::FUNCTION) {
								std::string comment = getIndent() + "# " +
													  var->name + " is stored ";
								if (var->storage == storageType::MEMORY) {
									if (var->offset < 0) comment += "at "+registerNAME(var->reg);
									else comment += "at "+registerNAME(var->reg)+"+";
									comment +=
										std::to_string((int64_t)var->offset);
								} else if (var->storage ==
										   storageType::REGISTER) {
									comment += "in " + registerNAME(var->reg);
								} else if (var->storage ==
										   storageType::MEMORY_ABSOLUTE) {
									std::stringstream stream;
									stream << std::hex << (int64_t)var->offset;
									comment += "at 0x" + stream.str();
								}
								currentScope->func->code.push_back(comment);
							}
							if (currentScope->t == scopeType::FUNCTION) {
								if (var->storage == storageType::REGISTER)
									currentScope->fstore->registerStatus(
										var->reg, 1);
							}
							if (var->storage == storageType::REGISTER) {
                                //(uint64_t)var->reg & 0x504C532043554D20494E53494445204D45 /* UwU */
								if (((uint64_t)var->reg & BITMASK_REGISTER_CPL) < options::fcpl) {
									if (warn(getWarning("cpl-registers"), &L,
											 "insufficient privilege level to "
											 "access register \"" +
												 registerNAME(var->reg) +
												 "\"")) {
										note("required privilege level: " +
											 std::to_string((uint64_t)var->reg &
															0x000000FF00) +
											 " or lower.");
										note("current privilege level: " + std::to_string(options::fcpl));
										note("use --fcpl <some number> or \"#pragma cpl <some number>\" to set the privilege level.");
									}
								}
                                if(var->reg == __register__::rsp)
                                {
                                    warn(getWarning("stack-pointer-rsp-storage"), &L, 
                                    "rsp is conventionally used to store the stack pointer, "
                                    "you should not mess with the stack pointer unless you know what you're doing!");
                                }
							} else if (var->storage ==
									   storageType::MEMORY_ABSOLUTE) {
								if (warn(getWarning("memory-absolute"), &L,
										 "saving variable at an absolute "
										 "address may be "
										 "unintentional"))
									note("use an explicit sign (+ or -) to "
										 "specifiy a relative "
										 "address");
							}
							if (currentScope->t == scopeType::CLASS) {
                                if (var->storage == storageType::REGISTER) {
									// error register storage invalid for member
									// variables
									std::cout << "BLUB BLUB" << std::endl;
								} else {
									if (var->storage ==
											storageType::MEMORY_ABSOLUTE &&
										var->isStatic == false) {
										// error absolute address only legal for
										// static members
										std::cout << "BLUB" << std::endl;
									} else {
										currentScope->cl->members.push_back(
											*var);
										if (currentScope->cl->size <
											var->offset + var->dataType->size)
											currentScope->cl->size =
												var->offset +
												var->dataType->size;
									}
								}
                                std::cout << "declared member: " << var->name << std::endl;
							} 
                            else
                            {
                                PRINT_DEBUG
                                currentScope->variables.push_back(var);
                                bool isPointer = var->dataType->name.back() == '*' ? true : false;
                                type* childTargetDataType = isPointer ? var->dataType->valueType : var->dataType;
                                //std::cout << "vdt: " << std::hex << (void*)var->dataType << std::endl;
                                //std::cout << "vdtvt: " << std::hex << (void*)var->dataType->valueType << std::endl;
                                //std::cout << "isPointer: " << isPointer << std::endl;
                                //std::cout << "ctdt: " << std::hex << (void*)childTargetDataType << std::endl;
                                if(childTargetDataType->members.size() > 0)
                                {
                                    PRINT_DEBUG
                                    if(var->storage == storageType::REGISTER && !isPointer)
                                    {
                                        PRINT_DEBUG
                                        if(var->usedAutoStorage)
                                        {
                                            //switch to memory storage
                                            std::cout << "switching storage of: " << var->name << std::endl;
                                            errorCompilerBug;
                                        }
                                        else
                                            std::cout << "ERROR: dont do that" << std::endl;
                                    }
                                    else
                                    {
                                        PRINT_DEBUG
                                        std::string msep = isPointer ? "->" : ".";
                                        if(isPointer)
                                        {
                                            PRINT_DEBUG
                                            for(variable i : childTargetDataType->members)
                                            {
                                                //init
                                                variable* child = new variable(i);
                                                child->doExport = false;
                                                //name
                                                child->name = var->name+msep+child->name;
                                                //storage
                                                child->storage = storageType::MEMORY;
                                                child->reg = var->reg;
                                                //finish up
                                                child->parent = var;
                                                var->children.push_back(child);
                                                currentScope->variables.push_back(child);
                                                //if(options::ddebug)
                                                    std::cout << "declared child: " << child->name << std::endl;
                                            }
                                        }
                                        else
                                        {
                                            PRINT_DEBUG
                                            for(variable i : childTargetDataType->members)
                                            {
                                                //init
                                                variable* child = new variable(i);
                                                child->doExport = false;
                                                //name
                                                child->name = var->name+msep+child->name;
                                                //storage
                                                child->reg = var->reg;
                                                child->offset += var->offset;
                                                //finish up
                                                child->parent = var;
                                                var->children.push_back(child);
                                                currentScope->variables.push_back(child);
                                                //if(options::ddebug)
                                                    std::cout << "declared child: " << child->name << std::endl;
                                            }
                                        }
                                    }
                                }
                            }
                            std::cout << "declared variable: " << var->name << std::endl;
							mOUT(moVariableID, var);
							t = L.nextToken();
							switch (t.type) {
								case (3): // operator
								{
									line tmpLine = L;
									tmpLine.stripTokens(attribs.size() + 1);
									std::vector<line> tmpLines;
									tmpLines.push_back(tmpLine);
									parse(tmpLines);
									break;
								}
                                case(6):
                                case(7):
                                case(11):
								case (1):
									variable* result = resolve(t);
                                    std::vector<variable*> args;
                                    args.push_back(var);
                                    args.push_back(result);
                                    function* func = getFunction("operator=", args);
							        if (func != nullptr) {
							        	if (func->isDeprecated)
							        		warn(getWarning("deprecated"), &L,
							        			 "call to deprecated function \"" +
							        				 func->name + "\"");
                                        //std::cout << "calling function " << func->name << std::endl;
							        	call(func, args);
							        }
									break;
							}
						}

						break;
					}
					case (10): {
						// do smth with variable
						break;
					}
					case (11): {
						// function call
						break;
					}
				}
				break;
			case (10): {
				// do smth with variable
				std::string name = t.text;
				variable* arg1	 = getVariable(t.text);
				t				 = L.nextToken();
				switch (t.type) {
					case (3):
						std::string functionName;
						std::string op = t.text;
						if (t.text == "=") functionName = "operator" + t.text;
						else if (t.text == "+=")
							functionName = "operator" + t.text;
						else if (t.text == "-=")
							functionName = "operator" + t.text;
						else if (t.text == "*=")
							functionName = "operator" + t.text;
						else if (t.text == "/=")
							functionName = "operator" + t.text;
						else if (t.text == "%=")
							functionName = "operator" + t.text;
						else if (t.text == "==")
							functionName = "operator" + t.text;
						else if (t.text == "|=")
							functionName = "operator" + t.text;
						else if (t.text == "&=")
							functionName = "operator" + t.text;
						else if (t.text == "^=")
							functionName = "operator" + t.text;
						else if (t.text == "!=")
							functionName = "operator" + t.text;
						else if (t.text == "*")
							functionName = "operator" + t.text;
						else if (t.text == "+")
							functionName = "operator" + t.text;
						else if (t.text == "-")
							functionName = "operator" + t.text;
						else if (t.text == "/")
							functionName = "operator" + t.text;
						else if (t.text == "++")
							functionName = "operator" + t.text;
						else if (t.text == "--")
							functionName = "operator" + t.text;
						else if (t.text == "^")
							functionName = "operator" + t.text;
						else {
							// unkown operator
							std::cout << "unknown operator: " << t.text
									  << std::endl;
						}

						t			   = L.nextToken();
                        if(options::asmVerbose >= 3)
                            if(currentScope->func != nullptr)
						        currentScope->func->code.push_back(getIndent() + "# " + L.text);
						variable* arg2 = resolve(t);
						if (arg2 == nullptr) {
							std::cout << "wtf?" << std::endl;
                            printLine(L);
						} else {
							std::vector<variable*> args;
							args.push_back(arg1);
							if (op != "++" && op != "--") args.push_back(arg2);
							function* func = getFunction(functionName, args);
							if (func != nullptr) {
								if (func->isDeprecated)
									warn(getWarning("deprecated"), &L,
										 "call to deprecated function \"" +
											 func->name + "\"");
                                //std::cout << "calling function " << func->name << std::endl;
								call(func, args);
							}
						}
				}
				break;
			}
			case (11): {
				// function call
                variable* result = resolve(t);
				break;
			}
			case (1): {
				// new unique identifier
				if (currentScope->t == scopeType::ENUM) {
					// declare new static enum member
				}
				break;
			}
			default:
                std::cout << "blub blub bug" << std::endl;
                printToken(t);
				std::cout << "line: " << L.text << std::endl;
		}
	ERRORENDLINE:;
    ENDLINE:;
		if (++i >= lines.size()) break;
	}
    ENDPARSER:;
    templateMode = 0;//cant ever be too sure in a file exceeding 2.000 lines LMFAO
}
