/*
 * Created Date: Tuesday July 25th 2023
 * Author: Lilith
 * -----
 * Last Modified: Thursday August 17th 2023 9:04:51 pm
 * Modified By: Lilith (definitelynotagirl115169@gmail.com)
 * -----
 * Copyright (c) 2023-2023 DefinitelyNotAGirl@github
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <codegen.h>
#include <common.h>
#include <compiler.h>
#include <error.h>
#include <execinfo.h>
#include <filesystem>
#include <mangling.h>
#include <miscout.h>
#include <options.h>
#include <rstack.h>
#include <signal.h>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <util.h>
#include <DWARF.h>

std::vector<std::string> DataCode;
std::vector<std::string> RoDataCode;
std::vector<std::string> BssCode;
std::vector<std::string> TextCode;
std::vector<std::string> MiscCode;
std::vector<std::string> DebugCode;
std::vector<std::string> DebugAbbrevCode;
uint64_t debugInfoSize = 0;//8 Bytes as mandated by DWARF-5
uint64_t dbgAbbrev = 1;

uint64_t DWARF_TYPE_ID = 1;

std::vector<std::string> includedFiles;
std::vector<std::string> dependencies;

std::string currentFile = "";

std::vector<line> getLines(std::string fname);

void monVarDeclared(variable* v)
{
    std::cout << "monitored variable declared!" << std::endl;
    return;
}

line compLine(std::string text)
{
    line l;
    l.file = "code generated by compiler";
    l.leadingSpaces = 0;
    l.lineNum = 0;
    l.text = text;
    return l;
}

std::string getIndent() {
	scope* sc = currentScope;
	std::string ret;
	while (sc != nullptr) {
        if(sc->t == scopeType::FUNCTION || sc->t == scopeType::CONDITIONAL_BLOCK || sc->t == scopeType::DUMMY || sc->t == scopeType::LOGICAL)
		    ret += "\t";
		sc = sc->parent;
	}
	return ret;
}

function* getFunction(std::string name)
{ 
    scope* sc = currentScope;
    while (sc != nullptr) {
		for (function* i : sc->functions) 
			if (i->name == name) 
                return i;
		sc = sc->parent;
	}
    return nullptr;
}

arch* getArch(std::string name)
{
    for(arch* i : architectures)
        if(i->name == name)
            return i;
    return nullptr;
}

_system* getSystem(std::string name)
{
    for(_system* i : systems)
        if(i->name == name)
            return i;
    return nullptr;
}

std::string getFunctionExpression(function* f, bool showVariableNames = false) {
	std::string res = f->returnType->name + " " + f->name + "(";
	if (!showVariableNames) {
		for (type* i : f->parameters)
			res += i->name + ",";
	} else {
		for (variable* i : f->vparams)
        {
			res += i->dataType->name + " " + i->name + ",";
        }
	}
	if (res.back() == ',') res.pop_back();
	res += ")";
	return res;
}

std::string getFunctionExpression(std::string name,
								  std::vector<variable*>& args) {
	std::string res = name + "(";
	for (variable* i : args)
	{
        //std::cout << "var: " << std::hex << (void*)i << std::endl;
        //std::cout << "var dt: " << std::hex << (void*)(i->dataType) << std::endl;
        res += i->dataType->name + ",";
    }
	if (res.back() == ',') 
        res.pop_back();
	res += ")";
	return res;
}

function* getFunction(const char* name, std::vector<variable*>& args)
{
    std::string n = name;
    return getFunction(n,args);
}

function* getFunction(std::string& name, std::vector<variable*>& args) {
	scope* sc = currentScope;
	std::vector<function*> candidates;
	while (sc != nullptr) {
		for (function* i : sc->functions) {
            //PRINT_DEBUG
			if (i->name == name) {
                //PRINT_DEBUG
				if (i->parameters.size() == args.size()) {
                    //PRINT_DEBUG
					for (uint64_t II = 0; II < i->parameters.size(); II++){
                        //PRINT_DEBUG
                        //std::cout << "name: " << name << std::endl;
                        //std::cout << "II: " << II << std::endl;
                        //std::cout << "args size: " << args.size() << std::endl;
                        //std::cout << "params size: " << i->parameters.size() << std::endl;
                        //std::cout << "aII: " <<std::hex << (void*)args[II] << std::endl;
                        //std::cout << "aII->dt: " <<std::hex << (void*)args[II]->dataType << std::endl;
						if (i->parameters[II] != args[II]->dataType)
							goto notThisFunction;
                    }
					// else
					//     std::cout <<std::hex<<i->parameters[II]<< " != " <<
					//     args[II] << std::endl;
					return i;
				}
			notThisFunction:;
				candidates.push_back(i);
			}
			//else
			//    std::cout << i->name <<" != "<< name << std::endl;
		}
		sc = sc->parent;
	}
    error::candidateExpressions.clear();
    error::functionExpr = getFunctionExpression(name, args);
	for (function* candidate : candidates)
		error::candidateExpressions.push_back(getFunctionExpression(candidate));
	return nullptr;
}

void printVariable(variable* v)
{
    std::cout << "##### variable #####" << std::endl;
    std::cout << "addr: " << std::hex << (void*)v << std::endl;
    std::cout << "name: " << v->name << std::endl;
    std::cout << "storage: " << (uint64_t)v->storage << std::endl;
    std::cout << "auto storage: " << v->usedAutoStorage << std::endl;
    std::cout << "reg: " << registerNAME(v->reg) << std::endl;
    std::cout << "offset: " << v->offset << std::endl;
    std::cout << "offsetReg: " << registerNAME(v->offsetReg) << std::endl;
    std::cout << "offsetType: " << (uint64_t)v->offsetType << std::endl;
    std::cout << "imm val: " << v->immediateValue << std::endl;
    std::cout << "####################" << std::endl;
}

variable* getVariable(std::string name) {
	scope* sc = currentScope;
	while (sc != nullptr) {
        //std::cout << "scanning scope: " << sc->name << std::endl;
		for (variable* i : sc->variables)
			if (i->name == name) return i;
            //else std::cout << "\"" << i->name << "\" != \"" << name << "\"" << std::endl;
		sc = sc->parent;
	}
	return nullptr;
}

void declareDwarfType(type* t)
{setANB(16);
    t->dwarfID = ++dbgAbbrev;
    //
    //.debug_info
    //
    DebugCode.push_back(getIndent()+".uleb128 "+intToString(dbgAbbrev));
    DebugCode.push_back(getIndent()+".string \""+t->name+"\"");
    DebugCode.push_back(getIndent()+".quad "+intToString(t->size));
    //
    //.debug_abbrev
    //
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString(dbgAbbrev));
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::TAG_class_type));
    DebugAbbrevCode.push_back(getIndent()+".byte 0");//no children
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_name));
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_string));
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_byte_size));
    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_data8));
    DebugAbbrevCode.push_back(getIndent()+".uleb128 0");//terminate
    DebugAbbrevCode.push_back(getIndent()+".uleb128 0");
popANB();}

type* getType(std::string name) {
    if(name == "operator*")
        return nullptr;
	for (type* t : types)
		if (t->name == name) return t;
	if (name.back() == '*') {
		// unknown pointer type, create a new type
		type* t = new type;
		t->name = name;
        t->dwarfID = DWARF_TYPE_ID++;
        std::string vtn = name.substr(0,name.length()-1);
        if(vtn == "__defuint")
            t->valueType = defaultUnsignedIntegerType;
        else if(vtn == "__defint")
            t->valueType = defaultSignedIntegerType;
        else if(vtn == "__defbool")
            t->valueType = defaultBooleanType;
        else if(vtn == "__defchar")
            t->valueType = defaultCharType;
        else if(vtn == "__defwchar")
            t->valueType = defaultWcharType;
        else if(vtn == "__deffloat")
            t->valueType = defaultFloatType;
        else if(vtn == "__defptr")
            t->valueType = defaultPointerType;
        else
            t->valueType = getType(vtn);
        if(!t->valueType)
        {
            //value type does not exist
            std::cout << "\033[31mERROR:\033[0m \"" << name.substr(0,name.length()-1) << "\" does not name a type!" << std::endl;
            return nullptr;
        }
        t->__declared_file = t->valueType->__declared_file;
        t->__declared_line = t->valueType->__declared_line;
		t->size = POINTER_SIZE;
        defaultMangler->mangle(t);
        declareDwarfType(t);
		types.push_back(t);
        std::vector<line> lines;
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=(__defptr,"+name+");"));
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=("+name+",__defptr);"));
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveAssign primitiveInPlace void operator=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveAdd primitiveInPlace void operator+=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveAdd primitiveInPlace void operator+=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveSub primitiveInPlace void operator-=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveSub primitiveInPlace void operator-=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveMul primitiveInPlace void operator*=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveMul primitiveInPlace void operator*=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveDiv primitiveInPlace void operator/=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveDiv primitiveInPlace void operator/=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveMod primitiveInPlace void operator%=("+name+",__defuint);"));
        lines.push_back(compLine("nodoc primitiveMod primitiveInPlace void operator%=("+name+","+name+");"));
        lines.push_back(compLine("nodoc primitiveInPlace primitiveArrayIndex "+t->valueType->name+" operator[]("+name+",__defuint);"));
        parse(lines);
		return t;
	}

	if (name.back() == '&' && name[name.length() - 2] != '&') {
		type* t = new type;
		t->name = name;
		t->size = POINTER_SIZE;
        defaultMangler->mangle(t);
        declareDwarfType(t);
		types.push_back(t);
		return t;
	}

	return nullptr;
}

void printToken(token& t)
{
    std::cout << "----- token -----" << std::endl;
    std::cout << "text: " << t.text << std::endl;
    std::cout << "type: " <<std::dec<< t.type << std::endl;
    std::cout << "-----------------" << std::endl;
}

void printLine(line& l)
{
    std::cout << "##### LINE #####" << std::endl;
    std::cout << "line: " << l.text << std::endl;
    std::cout << "indent: " << l.leadingSpaces << " / "<< currentScope->leadingSpace << std::endl;
}

void resetScope()
{
    currentScope = globalScope;
}

ABI* getABI(std::string name)
{
    for(ABI* abi : ABIs)
        if(abi->name == name)
            return abi;
    return nullptr;
}

scope* lastScope = nullptr;
void updateCurrentScope(scope* sc)
{
    if(options::ddebug)
        std::cout << "\033[35m[INFO]\033[0m updating scope: " << sc->name << std::endl;
    lastScope = currentScope;
    currentScope = sc;
    codeGenUpdateFuction();
}

void info(std::string i)
{
    std::cout << "\033[35m[INFO]\033[0m " << i << std::endl;
}

variable* getImmediateVariable(uint64_t v)
{
    variable* var = new variable;
    var->name = getNewName();
    var->dataType = defaultUnsignedIntegerType;
    var->storage = storageType::IMMEDIATE;
    var->immediateValue = v;
    return var;
}

variable* getRegisterHandle(__register__ reg)
{
    variable* var = new variable;
    var->name = getNewName();
    var->dataType = defaultUnsignedIntegerType;
    var->storage = storageType::REGISTER;
    var->reg = reg;
    return var;
}

std::string c2oLocExpr(variable* v)
{
    switch(v->storage)
    {
        case(storageType::MEMORY):{
            setANB(16);
            std::string ret = registerNAME(v->offsetReg)+",";
            ret += intToString(v->offset);
            ret += ",0x1";
            popANB();
            break;
        }case(storageType::MEMORY_ABSOLUTE):{
            setANB(16);
            std::string ret = "absolute,";
            ret += intToString(v->offset);
            ret += ",0x1";
            popANB();
            return ret;
            break;
        }case(storageType::REGISTER):{
            return registerNAME(v->reg);
            break;
        }
    }
    return "LOCATION";
}

class pdobj
{
public:
    std::string name;
    std::string desc;
};

class dObj
{
public:
    std::string desc;
    std::string ret;
    std::vector<pdobj*> params;
    std::vector<pdobj*> tparams;
};

dObj* currentd = new dObj;

void resetCurrentD()
{
    for(pdobj* i : currentd->params)
        delete i;
    for(pdobj* i : currentd->tparams)
        delete i;
    delete currentd;
    currentd = new dObj;
}

variable* __false__ = getImmediateVariable(0);

revstack<std::string> scopenames;

uint64_t templateMode = 0;//0: no template, 1: class template, 2: function template, 3: unknown
uint64_t lastTemplateMode = 0;
bool lastCSTM = false;
typeTemplate* __typeTemplate = nullptr;
functionTemplate* __functionTemplate = nullptr;
std::vector<templateArg*> templateArgs;
uint64_t dbgFileMax = 0;
std::stack<uint64_t> dbgFile;
extern std::string __reqFileVSTC;
bool isConstExprAssignment = false;
void parse(std::vector<line> lines) {
    if(lines.size() == 0)
        return;
	uint64_t i = 0;
    if(true /*check for GAS (true for now)*/ && options::debugSymbols)
    {
        //emit file debug information
        dbgFileMax++;
        dbgFile.push(dbgFileMax);
        if(code)
            code->push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
        else
            TextCode.push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
    }
    bool is_vstc_send = options::vstc && currentFile == __reqFileVSTC;
    bool is_vsls_send = options::vsls && currentFile == __reqFileVSTC;
	while (true) {
		line& L = lines[i];
		if (L.text.empty()) break;
        //if(currentFile == __reqFileVSTC)
        //{
        //    std::cout << "\033[34mline "<<L.lineNum<<": " << L.text <<"\033[0m"<< std::endl;
        //}
		token t = L.nextToken();
		bool isPrimitiveFunction = 0;
		bool isFunctionOnly		 = 0;
		std::vector<token> attribs;
        if(lastTemplateMode != templateMode)
        {
            std::cout << "template mode changed: " << lastTemplateMode << " -> " << templateMode << std::endl;
            lastTemplateMode = templateMode;
        }
        if(lastCSTM != currentScope->templateMode)
        {
            std::cout << "CSTM changed: " << lastCSTM << " -> " << currentScope->templateMode << std::endl;
            lastCSTM = currentScope->templateMode;
        }
        for(token& i : currentScope->attribs)
            attribs.push_back(i);
		if(options::ddebug)
		{
            std::cout << "##### LINE #####" << std::endl;
            std::cout << "number: " << L.lineNum << std::endl;
            std::cout << "line: " << L.text << std::endl;
            std::cout << "indent: " << L.leadingSpaces << " / "
					  << currentScope->leadingSpace << std::endl;
        }
		if ((L.leadingSpaces < currentScope->leadingSpace) 
            && currentScope->isIndentBased
            && L.file != "code generated by compiler"
            ){
			scope* ts = currentScope;
			while (true) {
				if (L.leadingSpaces < ts->leadingSpace) {
					if (options::ddebug) std::cout << "body ended: " << ts->name << std::endl;
					if (
                        ts->t == scopeType::FUNCTION
                        || ts->t == scopeType::CONDITIONAL_BLOCK
                        || ts->t == scopeType::LOGICAL
                        || ts->t == scopeType::DUMMY
                    ) {
                        //std::cout << "ended body: " << ts->func->symbol << std::endl;
                        //std::cout << "scope: " << ts->name << std::endl;
                        //std::cout << "blocks: " << ts->extraCodeBlocks.size() << std::endl;
                        if(ts->templateMode)
                        {
                            std::cout << "template complete" << std::endl;
                            templateArgs.clear();
                            __typeTemplate = nullptr;
                            __functionTemplate = nullptr;
                            templateMode = 0;
                        }
                        if(ts->t == scopeType::FUNCTION)
                        {
                            std::vector<std::string> lines;
                            if(!ts->func->isLocal)
								lines.push_back(getIndent()+".global " + ts->func->symbol);
                            if(!options::nod)
                            {
                                //optimizer data
                                lines.push_back("// @function "+ts->func->symbol);
                                for(variable* arg : ts->func->vparams)
                                    lines.push_back("// @parameter "+c2oLocExpr(arg));
                                lines.push_back("// @return rax");
                                for(__register__ i : ts->func->abi->VolatileRegisters)
                                    lines.push_back("// @modifies "+registerNAME(i));
                                for(__register__ i : ts->func->abi->nonVolatile)
                                    lines.push_back("// @preserves "+registerNAME(i));
                            }
                            //finish up function
						    ts->func->abi->genProlouge(lines, ts);
						    for (std::string& i : ts->func->code)
						    	lines.push_back(i);
						    ts->func->abi->genEpilouge(lines, ts);
                            for(std::vector<std::string>* block : ts->extraCodeBlocks)
                                for(std::string& i : *block)
                                    lines.push_back(i);
						    for (std::string& i : lines)
						    	TextCode.push_back(i);
                            TextCode.push_back("");
                            if(true /*check for GAS (true for now)*/ && options::debugSymbols)
                            {
                                //terminator
                                DebugCode.push_back(getIndent()+".uleb128 0");
                                DebugCode.push_back(getIndent()+".uleb128 0");
                            }
						    mOUT(moFunctionID, ts->func);
                        }
                        else if(ts->t == scopeType::CONDITIONAL_BLOCK)
                        {
                            //jump(ts->func,ts->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(ts->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry");
                            //if(ts->extraCodeBlocks.size() >= 2)
                            //    code = ts->extraCodeBlocks[1];
                            //else
                            //    code = ts->extraCodeBlocks.back();
                            jump(ts->reentrySymbol);
                            //code = &currentScope->func->code;
                            for(std::vector<std::string>* block : ts->extraCodeBlocks)
                            {
                                ts->parent->extraCodeBlocks.push_back(block);
                            }
                            if(ts->fstore->stackSize > ts->parent->fstore->stackSize)
                                ts->parent->fstore->stackSize = ts->fstore->stackSize;
                            //else
                            //    std::cout << ts->fstore->stackSize << " <= " << ts->parent->fstore->stackSize << std::endl;
                            //if(ts->fstore->stackOffset > ts->parent->fstore->stackOffset)
                            //    ts->parent->fstore->stackOffset = ts->fstore->stackOffset;
                        }
                        else if(ts->t == scopeType::LOGICAL)
                        {
                            for(std::string& i : ts->func->code)
                            {
                                //info("logical block line: "+i);
                                ts->parent->func->code.push_back(i);
                            }
                            for(std::vector<std::string>* block : ts->extraCodeBlocks)
                            {
                                //info("logical block end block: ");
                                //for(std::string& i : *block)
                                //    info("    "+i);
                                ts->parent->extraCodeBlocks.push_back(block);
                            }
                            if(ts->fstore->stackSize > ts->parent->fstore->stackSize)
                                ts->parent->fstore->stackSize = ts->fstore->stackSize;
                            //else
                            //    std::cout << ts->fstore->stackSize << " <= " << ts->parent->fstore->stackSize << std::endl;
                            //if(ts->fstore->stackOffset > ts->parent->fstore->stackOffset)
                            //    ts->parent->fstore->stackOffset = ts->fstore->stackOffset;
                        }
                        else if(ts->t == scopeType::DUMMY)
                        {
                            for(std::string& i : ts->func->code)
                            {
                                ts->parent->func->code.push_back(i);
                            }
                        }
					} else if (ts->t == scopeType::CLASS) {
                        //std::cout << "ended class body: " << ts->cl->mangledName << std::endl;
						ts->cl->incomplete = false;
						mOUT(moClassID, ts->cl);
					} else if (ts->t == scopeType::NAMESPACE) {
                        //std::cout << "ended namespace body: " << ts->name << std::endl;
					}
                    
                    ////clean up memory
                    //switch(ts->t)
                    //{
                    //    case(scopeType::CONDITIONAL_BLOCK):
                    //        delete ts;
                    //        break;
                    //}
                    //if(ts->parent != nullptr)
                    //{
                    //    if(ts->reentrySymbol != "")
                    //    {
                    //        updateCurrentScope(ts->parent);
                    //        std::cout << "placing reentry symbol: " << ts->reentrySymbol << std::endl;
                    //        std::cout << "parent: " << ts->parent->name << std::endl;
                    //        placeSymbol(ts->reentrySymbol);
                    //        if(ts->parent->lastReentrySym)
                    //            std::cout << "lrs: " << *ts->parent->lastReentrySym << std::endl;
                    //        std::cout << "code back: " << code->back() << std::endl; 
                    //        if(ts->parent->lastReentrySym)
                    //        {
                    //            if(*ts->parent->lastReentrySym == code->back())
                    //            {
                    //                std::cout << "clearing reentry sym: " << *ts->parent->lastReentrySym << std::endl;
                    //                ts->parent->lastReentrySym->clear();
                    //            }
                    //        }
                    //        std::cout << "code: " << code << std::endl;
                    //        ts->parent->lastReentrySym = &code->back();
                    //        if(ts->parent->lastReentrySym)
                    //            std::cout << "lrs: " << *ts->parent->lastReentrySym << std::endl;
                    //        updateCurrentScope(ts);
                    //    }
                    //}
                    if(ts->parent != nullptr)
                    {
                        ts->parent->lastReentrySym = ts->reentrySymbol;
                    }
					ts = ts->parent;
				} else {
					break;
				}
				if (ts == nullptr) {
					std::cout << "indentation error! (2)" << std::endl;
					break;
				}
			}
			updateCurrentScope(ts);
		} else if ((L.leadingSpaces > currentScope->leadingSpace) &&
				   currentScope->isIndentBased) {
			//std::cout << "indentation error! (1)" << std::endl;
		}
        if(/*t.text != "if" && */t.text != "else")
        {
            if(currentScope->lastReentrySym != "")
            {
                placeSymbol(currentScope->lastReentrySym);
                currentScope->lastReentrySym = "";
            }
        }
        if(currentScope->templateMode)
        {
            switch(templateMode)
            {
                case(1):
                    __typeTemplate->code.push_back(L);
                    goto ENDLINE;
                    break;
                default:
                    errorCompilerBug;
                    goto ERRORENDLINE;
            }
        }
        if(true /*check for GAS (true for now)*/ && options::debugSymbols)
        {
            //emit file debug information
            if(currentScope->t != scopeType::GLOBAL && currentScope->t != scopeType::NAMESPACE && currentScope->t != scopeType::CLASS)
            {
                if(code)
                    code->push_back(getIndent()+".loc "+std::to_string(dbgFile.top())+" "+std::to_string(L.lineNum));
            }
        }
        if(options::ddebug){
            info("first token: ");
            printToken(t);
        }
		switch (t.type) {
            case(14): //description directive
            {
                if(t.text == "@desc")
                {
                    if(currentd->desc.length() != 0)
                        currentd->desc.push_back('\x1A');
                    currentd->desc+=L.restText();
                }
                else if(t.text == "@return")
                {
                    if(currentd->ret.length() != 0)
                        currentd->ret.push_back('\x1A');
                    currentd->ret+=L.restText();
                }
                else if(t.text == "@param")
                {
                    pdobj* param = new pdobj;
                    param->name = L.nextToken().text;
                    param->desc = L.restText();
                    currentd->params.push_back(param);
                }
                else if(t.text == "@tparam")
                {
                    pdobj* tparam = new pdobj;
                    tparam->name = L.nextToken().text;
                    tparam->desc = L.restText();
                    currentd->params.push_back(tparam);
                }
                break;
            }
			case (5): // directive
                if (t.text == "#EOL") {
                    goto ENDLINE;
                } else if (t.text == "#EOF") {
                    goto ENDPARSER;
				} else if (t.text == "#include") {
                    if(options::ddebug)
                        std::cout << "include..." << std::endl;
					t = L.nextToken();
					switch (t.type) {
						case (6):{ // default width string literal
							// std::cout << "including file: " << t.text <<
							// std::endl;
                            std::string inc = t.text;
                            if (std::filesystem::exists(inc)) {
								std::string rstFile = currentFile;
                                currentFile = inc;
								parse(getLines(inc));
                                currentFile = rstFile;
                                resetScope();
                                includedFiles.push_back(inc);
                                if(true /*check for GAS (true for now)*/ && options::debugSymbols)
                                {
                                    //emit file debug information
                                    if(code)
                                        code->push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
                                    else
                                        TextCode.push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
                                }
							}
                            else
                                error::noSuchFile(t);
							break;
                        }
						case (34):
                            t = L.nextToken();
							//std::string fname =
							//	t.text.substr(1, t.text.length() - 2);
                            std::string fname = t.text;
							// std::cout << "sys include: " << fname <<
							// std::endl;
                            std::string inc;
							for (std::string i : includeDirs) {
								inc = i + "/" + fname;
								if (std::filesystem::exists(inc)) {
                                    std::string rstFile = currentFile;
                                    currentFile = inc;
									parse(getLines(inc));
                                    currentFile = rstFile;
                                    resetScope();
                                    includedFiles.push_back(inc);
                                    dependencies.push_back(inc);
									goto sysIncludeSuccess;
								}
								inc += ".h2";
								if (std::filesystem::exists(inc)) {
                                    std::string rstFile = currentFile;
                                    currentFile = inc;
									parse(getLines(inc));
                                    currentFile = rstFile;
                                    resetScope();
                                    includedFiles.push_back(inc);
                                    dependencies.push_back(inc);
									goto sysIncludeSuccess;
								}
							}
							error::noSuchFile(t);
						    sysIncludeSuccess:;
                            if(true /*check for GAS (true for now)*/ && options::debugSymbols)
                            {
                                //emit file debug information
                                if(code)
                                    code->push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
                                else
                                    TextCode.push_back(getIndent()+".file "+std::to_string(dbgFile.top())+" \""+currentFile+"\"");
                            }
                            if(options::ddebug)
                                std::cout << "included file: " << inc << std::endl;
						    break;
					}
				} else if (t.text == "#pragma") {
					t = L.nextToken();
					if (t.text == "push") {
						pragma::push();
					} else if (t.text == "pop") {
						pragma::pop();
					} else if (t.text == "warning") {
						t = L.nextToken();
						if (t.text == "enable") {
							t = L.nextToken();
							enableWarningSet(t.text);
						} else if (t.text == "disable") {
							t = L.nextToken();
							disableWarningSet(t.text);
						}
					} else if (t.text == "cpl") {
						t			  = L.nextToken();
						options::fcpl = atoi(t.text.c_str());
                    } else if (t.text == "ABI") {
						t			  = L.nextToken();
						ABI* abi = getABI(t.text);
                        if(abi == nullptr)
                        {
                            error::noSuchABI(t);
                        }
                        else
                            defaultABI = abi;
					} else if(t.text == "once") {
                        bool found = false;
                        for(std::string& i : includedFiles)
                        {
                            if(i == L.file)
                            {
                                found = true;
                                break;
                            }
                        }
                        if(found)
                        {
                            //std::cout << "parser stopped by \"#pragma once\"" << std::endl;
                            goto ENDPARSER;
                        }
                    } else if(t.text == "stack-pointer") {
                        t = L.nextToken();
                        StackPointer = registerID(t.text);
                    }
				} else if (t.text == "#autodecl") {
					t = L.nextToken();

					if (t.text == "integer") {
						// name
						t				 = L.nextToken();
						std::string name = t.text;
						// size
						t			  = L.nextToken();
						uint64_t size = std::stoi(t.text);
						std::vector<line> gLines;

						line l;
						l	   = L;
						l.tpos = 0;
						if (getType(name) == nullptr) {
							switch (size) {
								case (0):
									l.text = L.restText() + " class " + name +
											 " extends primitive0;";
									gLines.push_back(l);
									break;
								case (1):
									l.text = L.restText() + " class " + name +
											 " extends primitive8;";
									gLines.push_back(l);
									break;
								case (2):
									l.text = L.restText() + " class " + name +
											 " extends primitive16;";
									gLines.push_back(l);
									break;
								case (4):
									l.text = L.restText() + " class " + name +
											 " extends primitive32;";
									gLines.push_back(l);
									break;
								case (8):
									l.text = L.restText() + " class " + name +
											 " extends primitive64;";
									gLines.push_back(l);
									break;
							}
						}
						if (size > 0) {
                            if(defaultUnsignedIntegerType != nullptr){
                                if(defaultUnsignedIntegerType->name != name){
                                    l.text = L.restText() + " primitiveAssign primitiveInPlace void operator=(" + name + "," + defaultUnsignedIntegerType->name + ");";
						        	gLines.push_back(l);
                                    //std::cout << "gline: " << l.text << std::endl;
                                }
                                //else
                                //{
                                //    std::cout << "\""<<name<<"\" == \"" << defaultUnsignedIntegerType->name << "\"" << std::endl;
                                //}
                            }
                            else
                            {
                                warn(getWarning("autodecl-nodef-uint"),&L,"\"#autodecl integer\" used before assigning a default unsigned integer type.");
                            }
							l.text = L.restText() + " primitiveMul " + name +
									 " operator*(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + " primitiveDiv " + name +
									 " operator/(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + " primitiveAdd " + name +
									 " operator+(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + " primitiveSub " + name +
									 " operator-(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() + " primitiveMod " + name +
									 " operator%(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveMul primitiveInPlace void "
									 "operator*=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveDiv primitiveInPlace void "
									 "operator/=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveAdd primitiveInPlace void "
									 "operator+=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveSub primitiveInPlace void "
									 "operator-=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveMod primitiveInPlace void "
									 "operator%=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveEqual "+defaultBooleanType->name+" operator==(" + name +"," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveGreater "+defaultBooleanType->name+" operator>(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveGreaterEqual "+defaultBooleanType->name+" operator>=(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveLessEqual "+defaultBooleanType->name+" operator<=(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveLess "+defaultBooleanType->name+" operator<(" + name + "," + name + ");";
							gLines.push_back(l);
                            l.text = L.restText() +" primitiveNotEqual "+defaultBooleanType->name+" operator!=(" + name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveAssign primitiveInPlace void "
									 "operator=(" +
									 name + "," + name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveInc primitiveInPlace void "
									 "operator++(" +
									 name + ");";
							gLines.push_back(l);
							l.text = L.restText() +
									 " primitiveDec primitiveInPlace void "
									 "operator--(" +
									 name + ");";
							gLines.push_back(l);
                            if(name != defaultUnsignedIntegerType->name)
                            {
                                    l.text = L.restText() + " primitiveMul " + name +
							    		 " operator*(" + name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() + " primitiveDiv " + name +
							    		 " operator/(" + name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() + " primitiveAdd " + name +
							    		 " operator+(" + name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() + " primitiveSub " + name +
							    		 " operator-(" + name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() + " primitiveMod " + name +
							    		 " operator%(" + name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() +
							    		 " primitiveMul primitiveInPlace void "
							    		 "operator*=(" +
							    		 name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() +
							    		 " primitiveDiv primitiveInPlace void "
							    		 "operator/=(" +
							    		 name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() +
							    		 " primitiveAdd primitiveInPlace void "
							    		 "operator+=(" +
							    		 name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() +
							    		 " primitiveSub primitiveInPlace void "
							    		 "operator-=(" +
							    		 name + ",__defuint);";
							    gLines.push_back(l);
							    l.text = L.restText() +
							    		 " primitiveMod primitiveInPlace void "
							    		 "operator%=(" +
							    		 name + ",__defuint);";
                                l.text = L.restText() +" primitiveEqual "+defaultBooleanType->name+" operator==(" + name +",__defuint);";
                                gLines.push_back(l);
                                l.text = L.restText() +" primitiveGreater "+defaultBooleanType->name+" operator>(" + name + ",__defuint);";
                                gLines.push_back(l);
                                l.text = L.restText() +" primitiveGreaterEqual "+defaultBooleanType->name+" operator>=(" + name + ",__defuint);";
                                gLines.push_back(l);
                                l.text = L.restText() +" primitiveLessEqual "+defaultBooleanType->name+" operator<=(" + name + ",__defuint);";
                                gLines.push_back(l);
                                l.text = L.restText() +" primitiveLess "+defaultBooleanType->name+" operator<(" + name + ",__defuint);";
                                gLines.push_back(l);
                                l.text = L.restText() +" primitiveNotEqual "+defaultBooleanType->name+" operator!=(" + name + ",__defuint);";
                                gLines.push_back(l);
                            }
						}
						if (gLines.size() > 0) parse(gLines);
					}
				} else if (t.text == "#outcom") {
                    std::string comment = L.restText();
                    putComment(comment);
                }
				break;
            case (26):
			case (25):
			case (22):
			case (21):
			case (20):
            case (30):
			collectAttributes:;
				while (t.type >= 20 && t.type < 31) {
                    if(t.type == 30)
                    {
                        t = L.nextToken();
                        std::string text = "("+t.text;
                        t = L.nextToken();
                        if(t.type == 31)
                            text+=")";
                        else
                        {
                            std::cout << ":skull:" << std::endl;
                            goto ERRORENDLINE;
                        }
                        t.text = text;
                    }
					attribs.push_back(t);
					t = L.nextToken();
				}
				// std::cout << "attributes: ";
				// for(token& a : attribs)
				//     std::cout << a.text << " ";
				// std::cout << std::endl;
			case (8): // keyword
				if (t.type == 8) {
					if (t.text == "enum") {
						t = L.nextToken();
						switch (t.type) {
							case (9): {
								// id redefinition error
								break;
							}
							case (1): {
								type* ntype		  = new type;
								mangler* mangling = defaultMangler;
								ntype->name		  = t.text;
                                token nametoken = t;
								ntype->size		  = 8;
                                ntype->__declared_file = currentFile;
                                ntype->__declared_line = L.lineNum;

								for (token& attr : attribs) {
									if (attr.text == "nodoc")
										ntype->nodoc = true;
									else if (attr.text == "deprecated")
										ntype->deprecated = true;
									else if (attr.text == "export")
										ntype->doExport = true;
									else if (attr.text.substr(
												 0, strlen("mangling-")) ==
											 "mangling-") {
										std::string manglerName =
											attr.text.substr(
												strlen("mangling-"),
												attr.text.length());
										mangling = getMangler(manglerName);
										if (mangling == nullptr) {
											std::cout << "ERROR: mangler \""
													  << manglerName
													  << "\" does not exist!"
													  << std::endl;
										}
									} else {
										error::invalidClassAttribute(attr);
										goto ERRORENDLINE;
									}
								}
								if (ntype->name.back() == ':')
									ntype->name.pop_back();
								mangling->mangle(ntype);
								if (L.text.back() == ':') {
									// indent based body
									scope* sc  = new scope;
									sc->parent = currentScope;
									sc->name = currentScope->name + CPE2_SYMBOL_SCOPE_SEP +ntype->mangledName;
									sc->leadingSpace =
										L.leadingSpaces + tabLength;
									sc->isIndentBased = true;
									sc->t			  = scopeType::ENUM;
									sc->cl			  = ntype;
									updateCurrentScope(sc);
									if (options::ddebug)
										std::cout << "enum body started: " << ntype->name << std::endl;
								} else {
									mOUT(moClassID, ntype);
								}
                                declareDwarfType(ntype);
								types.push_back(ntype);
								break;
							}
						}
					} else if (t.text == "class") {
						t = L.nextToken();
						switch (t.type) {
							case (9): {
								// class redefinition error
                                error::expectedNewUnique(t);
								break;
							}
							case (1): {
								type* ntype		  = new type;
                                ntype->desc = currentd->desc;
                                resetCurrentD();
								mangler* mangling = defaultMangler;
								ntype->name		  = t.text;
                                token nametoken = t;
								ntype->size		  = 0;
                                ntype->__declared_file = currentFile;
                                ntype->__declared_line = L.lineNum;
								t				  = L.nextToken();
                                token f = t;
								switch (t.type) {
									case (40):
										goto collectInheritance;
									case (8):
										if (t.text == "extends") {
										collectInheritance:;
											// collect types to inherit from
                                            int64_t startOffset = 0;
											t = L.nextToken();
                                            if(t.type == 0)
                                            {
                                                t = f;
                                                goto noMoreInheritance;
                                            }
											while (t.type == 9 ||
												   t.type == 12) {
												if (t.type == 12) {
													if (t.text == "primitive64") {
														ntype->size += 8;
														startOffset += 8;
													} else if (t.text == "primitive32") {
														ntype->size += 4;
														startOffset += 4;
													} else if (t.text == "primitive16") {
														ntype->size += 2;
														startOffset += 2;
													} else if (t.text == "primitive8") {
														ntype->size += 1;
														startOffset += 1;
													} else if (t.text == "primitiveFloat64") {
														ntype->size += 8;
														startOffset += 8;
													} else if (t.text == "primitiveFloat32") {
														ntype->size += 4;
														startOffset += 4;
													}
												} else if (t.type == 9) {
													type* it = getType(t.text);
													if (it == nullptr) {
														error::noSuchType(t);
														delete ntype;
														goto ERRORENDLINE;
													}
													for (variable m :
														 it->members) {
														m.offset += startOffset;
														ntype->members
															.push_back(m);
													}
													startOffset += it->size;
												}
												t = L.nextToken();
                                                switch(t.type)
                                                {
                                                    case(40):
                                                    case(41):
                                                        goto noMoreInheritance;
                                                    case(42):
                                                        break;
                                                    default:
                                                        error::noSuchType(t);
                                                        delete ntype;
                                                }
                                                t = L.nextToken();
											}
                                            noMoreInheritance:;
											ntype->size = startOffset;
										}
										break;
								}
								for (token& attr : attribs) {
									if (attr.text == "nodoc")
										ntype->nodoc = true;
									else if (attr.text == "iteratable")
										ntype->iteratable = true;
									else if (attr.text == "deprecated")
										ntype->deprecated = true;
									else if (attr.text == "export")
										ntype->doExport = true;
                                    else if (attr.text == "defaultSignedInt")
										defaultSignedIntegerType = ntype;
                                    else if (attr.text == "defaultUnsignedInt")
										defaultUnsignedIntegerType = ntype;
                                    else if (attr.text == "defaultBool")
										defaultBooleanType = ntype;
                                    else if (attr.text == "defaultFloat")
										defaultFloatType = ntype;
                                    else if (attr.text == "defaultChar")
										defaultCharType = ntype;
                                    else if (attr.text == "defaultWchar")
										defaultWcharType = ntype;
                                    else if (attr.text == "defaultPointer")
										defaultPointerType = ntype;
									else if (attr.text.substr(
												 0, strlen("mangling-")) ==
											 "mangling-") {
										std::string manglerName =
											attr.text.substr(
												strlen("mangling-"),
												attr.text.length());
										mangling = getMangler(manglerName);
										if (mangling == nullptr) {
											std::cout << "ERROR: mangler \""
													  << manglerName
													  << "\" does not exist!"
													  << std::endl;
										}
									} else {
										error::invalidClassAttribute(attr);
										goto ERRORENDLINE;
									}
								}
								mangling->mangle(ntype);
								if (t.type == 40) {
									// indent based body
									ntype->incomplete = true;
									scope* sc		  = new scope;
									sc->parent		  = currentScope;
									sc->name = currentScope->name + CPE2_SYMBOL_SCOPE_SEP +ntype->mangledName;
									sc->leadingSpace = L.leadingSpaces + tabLength;
									sc->isIndentBased = true;
									sc->t			  = scopeType::CLASS;
									sc->cl			  = ntype;
                                    if(templateMode == 3)
                                    {
                                        sc->templateMode = true;
                                        __typeTemplate = new typeTemplate;
                                        __typeTemplate->tArgs = templateArgs;
                                        __typeTemplate->name = ntype->name;
                                        templateMode = 1;
                                    }
									updateCurrentScope(sc);
									if (options::ddebug)
										std::cout << "class body started: " << ntype->name << std::endl;
								} else if (t.type == 41) {
									mOUT(moClassID, ntype);
								} else {
                                    printToken(t);
                                    errorCompilerBug;
                                }
                                if(templateMode == 0)
                                {
                                    declareDwarfType(ntype);
								    types.push_back(ntype);
                                    if(is_vstc_send)std::cout << "0001\x0c" << nametoken.lineNum <<'\x0c'<< nametoken.col <<'\x0c'<< nametoken.text.length() <<'\x0c'<<nametoken.text<<'\x0c'<<ntype->__declared_file<<'\x0c'<<std::to_string(ntype->__declared_line)<<'\x0c'<<ntype->desc<<'\n';
                                }
                                else
                                    std::cout << "template mode: " << templateMode << std::endl;
                                //std::cout << "most recent type: " << types.back()->name << std::endl;
								break;
							}
							default:
								// error unexpected token
                                error::expectedNewUnique(t);
								break;
						}
					} else if (t.text == "litop") {
                        //0x492057414E542042494720434F434B
						t = L.nextToken();
						switch (t.type) {
							case (1): {
								litop* lop = new litop;
								lop->name  = t.text;
								t		   = L.nextToken();
								switch (t.type) {
									case (13):
										if (t.text == "add")
											lop->op = shortOP::ADD;
										else if (t.text == "sub")
											lop->op = shortOP::SUB;
										else if (t.text == "mul")
											lop->op = shortOP::MUL;
										else if (t.text == "div")
											lop->op = shortOP::DIV;
										else if (t.text == "cast")
											lop->op = shortOP::CAST;

										if (lop->op == shortOP::CAST) {
											t = L.nextToken();
											switch (t.type) {
												case (9): {
													type* ct = getType(t.text);
													if (ct == nullptr) {
														error::noSuchType(t);
														delete lop;
														goto ERRORENDLINE;
													}
													break;
												}
												default:
													error::noSuchType(t);
													delete lop;
													goto ERRORENDLINE;
											}
										} else {
											t = L.nextToken();
											lop->value =
												resolve(t)->immediateValue;
											litops.push_back(lop);
										}
										break;
									default:
										error::expectedShortop(t);
								}
								break;
							}
							default: {
								error::expectedNewUnique(t);
							}
						}
					} else if (t.text == "namespace") {
						std::vector<std::string> nsp;
						t = L.nextToken();
                        bool wasColon = false;
                        while(true)
                        {
                            if(t.type == 40)
                                if(wasColon)
                                    wasColon = false;
                                else
                                {
                                    wasColon = true;
                                    break;
                                }
                            else if(t.type == 1)
                                nsp.push_back(t.text);
                            t = L.nextToken();
                        }
						std::string symb = currentScope->name;
						scope* sco		 = nullptr;
						for (std::string ns : nsp) {
							scope* sc = new scope;
							sc->t	  = scopeType::NAMESPACE;
							if (!symb.empty()) symb += CPE2_SYMBOL_SCOPE_SEP;
							symb += ns;
							sc->name   = symb;
							sc->parent = currentScope;
							if (sco) sc->lparent = sco;
							else sc->lparent = currentScope;
							sco = sc;
                            if(options::ddebug)
							    std::cout << "declared namespace: " << symb<< std::endl;
						}
						if(wasColon) 
                        {
                            sco->leadingSpace = L.leadingSpaces + tabLength;
                            updateCurrentScope(sco);
                        }
                        sco->attribs = attribs;
					} else if (t.text == "return") {
                        if(options::ddebug)std::cout << "return" << std::endl;
                        if(currentScope->t == scopeType::GLOBAL)
                        {
                            error::lbGlobalScope(t);
                            goto ERRORENDLINE;
                        }
                        t = L.nextToken();
                        variable* retVal = resolve(t);
                        variable* ret = new variable;
                        //std::cout << "cs: " << currentScope->name << std::endl;
                        //std::cout << "line: " << L.text << std::endl;
                        ret->storage = storageType::REGISTER;
                        ret->reg = currentScope->func->abi->integerReturn;
                        ret->dataType = currentScope->func->returnType;
                        if(retVal == nullptr)
                        {
                            error::genericError(0x2001);
                            goto ERRORENDLINE;
                        }
                        else if(ret == nullptr)
                        {
                            error::genericError(0x2002);
                            goto ERRORENDLINE;
                        }
                        else
                            mov(retVal,ret);
                        jump(currentScope->func,currentScope->func->symbol+CPE2_SYMBOL_SCOPE_SEP+"epilogue");
                    } else if (t.text == "while") {
                        //parse condition line
                        if(options::asmSepComments)putComment("");
                        scope* sc = new scope;
                        sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"while"+std::to_string(currentScope->whileCounter++);
                        sc->parent = currentScope;
                        sc->isIndentBased = true;
                        sc->t = scopeType::CONDITIONAL_BLOCK;
                        sc->fstore = new functionStorage;
                        sc->func = new function;
                        *(sc->func) = *(currentScope->func);
                        *(sc->fstore) = *(currentScope->fstore);
                        sc->func->code = std::vector<std::string>();
                        sc->reentrySymbol = sc->name+CPE2_SYMBOL_SCOPE_SEP"reentry";
                        sc->leadingSpace=currentScope->leadingSpace+tabLength;
                        placeSymbol(sc->reentrySymbol);
                        line conditionLine = L;
                        conditionLine.tpos = 0;
                        conditionLine.text = L.restText();
                        token cond = conditionLine.nextToken();
                        //std::cout << "condition: " << cond.text << std::endl;
                        variable* condition = resolve(cond);
                        //cmp(__false__,condition);
                        jc(sc->name);
                        if(options::asmSepComments)putComment("");
                        //prepare for body
                        updateCurrentScope(sc);
                        std::vector<std::string>* endcode = new std::vector<std::string>;
                        for(std::string& i : currentScope->func->code)
                            endcode->push_back(i);
                        currentScope->func->code = std::vector<std::string>();
                        currentScope->extraCodeBlocks.push_back(&currentScope->func->code);
                        currentScope->extraCodeBlocks.push_back(endcode);
                        placeSymbol(currentScope->name);
                    } else if (t.text == "for") {
                        t = L.nextToken();
                        //construct new scope
                        scope* sc = new scope;
                        sc->leadingSpace=currentScope->leadingSpace+tabLength;
                        sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"forloop"+std::to_string(currentScope->forCounter++);
                        sc->parent = currentScope;
                        sc->isIndentBased = true;
                        sc->t = scopeType::LOGICAL;
                        sc->fstore = new functionStorage;
                        sc->func = new function;
                        //sc->parent->conditionalCounter++;
                        *(sc->func) = *(currentScope->func);
                        *(sc->fstore) = *(currentScope->fstore);
                        sc->func->code = std::vector<std::string>();
                        //currentScope->reentrySymbol = sc->parent->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                        //sc->extraCodeBlocks.push_back(&sc->func->code);
                        updateCurrentScope(sc);
                        placeSymbol(currentScope->name);
                        //parse begin line
                        line beginLine = L;
                        beginLine.text = L.restText();
                        beginLine.tpos = 0;
                        beginLine.leadingSpaces+=tabLength;
                        std::vector<line> beginLines = {beginLine};
                        parse(beginLines);
                        //parse condition line
                        if(options::asmSepComments)putComment("");
                        sc = new scope;
                        sc->leadingSpace=currentScope->leadingSpace;
                        sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"body";
                        sc->parent = currentScope;
                        sc->isIndentBased = true;
                        sc->t = scopeType::CONDITIONAL_BLOCK;
                        sc->fstore = new functionStorage;
                        sc->func = new function;
                        *(sc->func) = *(currentScope->func);
                        *(sc->fstore) = *(currentScope->fstore);
                        sc->func->code = std::vector<std::string>();
                        sc->reentrySymbol = sc->parent->name+CPE2_SYMBOL_SCOPE_SEP"reentry";
                        placeSymbol(sc->reentrySymbol);
                        line conditionLine = lines[++i];
                        token cond = conditionLine.nextToken();
                        //std::cout << "condition: " << cond.text << std::endl;
                        variable* condition = resolve(cond);
                        //cmp(__false__,condition);
                        jc(sc->name);
                        if(options::asmSepComments)putComment("");
                        //parse end line
                        updateCurrentScope(sc);
                        if(options::asmSepComments)putComment("");
                        line endLine = lines[++i];
                        {
                            uint64_t bi = endLine.text.size()-1;
                            while(endLine.text[bi] != ':')
                                bi--;
                            while(endLine.text[bi] != ')')
                                bi--;
                            endLine.text = endLine.text.substr(0,bi);
                        }
                        endLine.leadingSpaces = currentScope->leadingSpace;
                        std::vector<line> endLines = {endLine};
                        parse(endLines);
                        //prepare for body
                        std::vector<std::string>* endcode = new std::vector<std::string>;
                        for(std::string& i : currentScope->func->code)
                            endcode->push_back(i);
                        currentScope->func->code = std::vector<std::string>();
                        currentScope->extraCodeBlocks.push_back(&currentScope->func->code);
                        currentScope->extraCodeBlocks.push_back(endcode);
                        placeSymbol(currentScope->name);
                    } else if (t.text == "if") {
                        if(currentScope->t == scopeType::GLOBAL)
                        {
                            error::lbGlobalScope(t);
                            goto ERRORENDLINE;
                        }
                        if(options::ddebug)std::cout << "if" << std::endl;
                        if(options::asmSepComments)putComment("");
                        scope* sc = new scope;
                        sc->leadingSpace=currentScope->leadingSpace+tabLength;
                        sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"if"+std::to_string(currentScope->ifCounter++);
                        sc->parent = currentScope;
                        sc->isIndentBased = true;
                        sc->t = scopeType::CONDITIONAL_BLOCK;
                        sc->fstore = new functionStorage;
                        sc->func = new function;
                        sc->parent->conditionalCounter++;
                        //std::cout << "transfer " << currentScope->name << " -> " << sc->name << std::endl;
                        *(sc->func) = *(currentScope->func);
                        *(sc->func->fstore) = *(currentScope->func->fstore);
                        *(sc->fstore) = *(currentScope->fstore);
                        //std::cout << "parent stack offset: " <<std::dec<< sc->fstore->stackOffset << std::endl;
                        //std::cout << "parent func stack offset: " <<std::dec<< sc->func->fstore->stackOffset << std::endl;
                        //std::cout << "parent stack size: " <<std::dec<< sc->fstore->stackSize << std::endl;
                        //std::cout << "parent func stack size: " <<std::dec<< sc->func->fstore->stackSize << std::endl;
                        sc->func->code = std::vector<std::string>();
                        sc->reentrySymbol = currentScope->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                        sc->extraCodeBlocks.push_back(&sc->func->code);
                        //generate conditional jump code
                        line cl = L;
                        cl.text = "";
                        cl.tpos = 0;
                        token cond;
                        if(t.type == 30)
                        {
                            t = L.nextToken();
                            cond = t;
                            //while(cond.type != 31)//while != )
                            //{
                            //    //std::cout << "type: " << t.type << std::endl;
                            //    //std::cout << "text: " << 
                            //    cond = L.nextToken();
                            //    cl.text += cond.text;
                            //}
                            //cl.tpos = 0;
                            for(char c : L.restText())
                            {
                                switch(c)
                                {
                                    case(')'):
                                        goto endCLine0;
                                    default:
                                        cl.text.push_back(c);
                                }
                            }
                            endCLine0:;
                        }
                        else
                        {
                            cond = t;
                            while(cond.type != 40)//while != :
                            {
                                cond = L.nextToken();
                                //if(cond.type != 40) {
                                //    cl.text += cond.text;
                                //}
                            }
                            //cl.tpos = 0;
                            for(char c : L.restText())
                            {
                                switch(c)
                                {
                                    case(':'):
                                        goto endCLine1;
                                    default:
                                        cl.text.push_back(c);
                                }
                            }
                            endCLine1:;
                        }
                        cond = cl.nextToken();
                        //std::cout << "condition: " << cond.text << std::endl;
                        variable* condition = resolve(cond);
                        //cmp(__false__,condition);
                        jc(sc->name);
                        if(options::asmSepComments)putComment("");
                        //set return symbol
                        updateCurrentScope(sc);
                        placeSymbol(sc->func,sc->name);
                    } else if (t.text == "else") {
                        if(currentScope->t == scopeType::GLOBAL)
                        {
                            error::lbGlobalScope(t);
                            goto ERRORENDLINE;
                        }
                        t = L.nextToken();
                        if(t.text == "if")
                        {
                            if(options::ddebug)std::cout << "else if" << std::endl;
                            if(options::asmSepComments)putComment("");
                            scope* sc = new scope;
                            sc->leadingSpace=currentScope->leadingSpace+tabLength;
                            sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"elseif"+std::to_string(currentScope->elseIfCounter++);
                            sc->parent = currentScope;
                            sc->isIndentBased = true;
                            sc->t = scopeType::CONDITIONAL_BLOCK;
                            sc->fstore = new functionStorage;
                            sc->func = new function;
                            *(sc->func) = *(currentScope->func);
                            *(sc->fstore) = *(currentScope->fstore);
                            //std::cout << "transfer " << currentScope->name << " -> " << sc->name << std::endl;
                            sc->func->code = std::vector<std::string>();
                            sc->extraCodeBlocks.push_back(&sc->func->code);
                            sc->reentrySymbol = currentScope->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                            //generate conditional jump code
                            line cl = L;
                            cl.text = "";
                            cl.tpos = 0;
                            token cond;
                            if(t.type == 30)
                            {
                                t = L.nextToken();
                                cond = t;
                                //while(cond.type != 31)//while != )
                                //{
                                //    //std::cout << "type: " << t.type << std::endl;
                                //    //std::cout << "text: " << 
                                //    cond = L.nextToken();
                                //    cl.text += cond.text;
                                //}
                                //cl.tpos = 0;
                                for(char c : L.restText())
                                {
                                    switch(c)
                                    {
                                        case(')'):
                                            goto endCLine2;
                                        default:
                                            cl.text.push_back(c);
                                    }
                                }
                                endCLine2:;
                            }
                            else
                            {
                                cond = t;
                                while(cond.type != 40)//while != :
                                {
                                    cond = L.nextToken();
                                    //if(cond.type != 40) {
                                    //    cl.text += cond.text;
                                    //}
                                }
                                //cl.tpos = 0;
                                for(char c : L.restText())
                                {
                                    switch(c)
                                    {
                                        case(':'):
                                            goto endCLine3;
                                        default:
                                            cl.text.push_back(c);
                                    }
                                }
                                endCLine3:;
                            }
                            cond = cl.nextToken();
                            //std::cout << "condition: " << cond.text << std::endl;
                            variable* condition = resolve(cond);
                            variable* __false__ = getImmediateVariable(0);
                            //cmp(__false__,condition);
                            jc(sc->name);
                            if(options::asmSepComments)putComment("");
                            //set return symbol
                            updateCurrentScope(sc);
                            placeSymbol(sc->func,sc->name);
                        }
                        else
                        {
                            if(options::ddebug)std::cout << "else" << std::endl;
                            scope* sc = new scope;
                            sc->leadingSpace=currentScope->leadingSpace+tabLength;
                            sc->name=currentScope->name+CPE2_SYMBOL_SCOPE_SEP"else"+std::to_string(currentScope->elseCounter++);
                            sc->parent = currentScope;
                            sc->isIndentBased = true;
                            sc->t = scopeType::LOGICAL;
                            sc->fstore = new functionStorage;
                            sc->func = new function;
                            *(sc->func) = *(currentScope->func);
                            *(sc->fstore) = *(currentScope->fstore);
                            sc->func->code = std::vector<std::string>();
                            sc->reentrySymbol = currentScope->name+CPE2_SYMBOL_SCOPE_SEP"conditional"+std::to_string(sc->parent->conditionalCounter)+CPE2_SYMBOL_SCOPE_SEP"reentry";
                            //sc->extraCodeBlocks.push_back(&sc->func->code);
                            //set return symbol
                            updateCurrentScope(sc);
                            placeSymbol(currentScope->name);
                        }
                    } else if (t.text == "template") {
                        t = L.nextToken();
                        if(t.type == 34)
                        {
                            templateArgs.clear();
                            while (true) {
								t = L.nextToken();
                                templateArg* ta = new templateArg;
								switch (t.type) {
									case (50):
										if(t.text == "typename")
                                            ta->Type = 2;
                                        else if(t.text == "integer")
                                            ta->Type = 1;
                                        else if(t.text == "float")
                                            ta->Type = 3;
                                        else
                                        {
                                            error::expectedTemplateArg(t);
                                            goto ERRORENDLINE;
                                        }
										break;
                                    case(35):
                                        goto TEMPLATENOARGS;
                                        break;
									default:
										error::expectedTemplateArg(t);
										goto ERRORENDLINE;
								}
                                t = L.nextToken();
                                switch (t.type) {
                                    case(1):
                                        ta->name = t.text;
                                        t = L.nextToken();
                                        break;
                                    case(35):
                                        goto TEMPLATENOARGS;
                                        break;
									default:
										error::expectedNewUnique(t);
										goto ERRORENDLINE;
								}
                                templateArgs.push_back(ta);
							}
                            TEMPLATENOARGS:;
                            templateMode = 3;
                        }
                        else
                        {
                            //syntax error, no < after template keyword
                        }
                    }
					break;
				}
			case (9):
				switch (t.type) {
					case (9): {
						// function or variable declaration
                        uint64_t arraySizeCount = 0;
                        bool isArray = 0;
						type* it = getType(t.text);
						if (it == nullptr) {
							error::noSuchType(t);
							goto ERRORENDLINE;
						}
						t				 = L.nextToken();
                        line arrayCountLine = L;
                        arrayCountLine.tpos = 0;
                        arrayCountLine.text = "";
                        if(t.type == 32)
                        {
                            t = L.nextToken();
                            while(t.type != 33)
                            {
                                arrayCountLine.text += t.text;
                                t = L.nextToken();
                            }
                            isArray = true;
                            token sizeToken = arrayCountLine.nextToken();
                            variable* size = resolve(sizeToken);
                            if(size->storage != storageType::IMMEDIATE)
                            {
                                error::arraySizeImmediate(t);
                                goto ERRORENDLINE;
                            }
                            arraySizeCount = size->immediateValue;
                            it = getType(it->name+"*");
                            t = L.nextToken();
                        }
                        token nametoken = t;
						std::string name = t.text;
						bool isFunction	 = false;
                        t = L.nextToken();
                        if(t.type == 30)
                        {
                            //t = L.nextToken();
                            isFunction = true;
                        }
						if (isFunction) {
                            if(is_vstc_send)std::cout << "0003\x0c" << nametoken.lineNum <<'\x0c'<< nametoken.col <<'\x0c'<< nametoken.text.length() <<'\x0c'<<nametoken.text<<'\x0c'<<currentFile<<'\x0c'<<std::to_string(L.lineNum)<<'\x0c'<<it->name<<'\x0c'<<currentd->desc<<'\x0c'<<currentd->ret<<'\n';
							mangler* mangling	  = defaultMangler;
							bool isStatic		  = false;
							bool isInline		  = false;
							bool isExtern		  = false;
							bool isConst		  = false;
							bool isNoop			  = false;
                            bool isNoReturn		  = false;
							bool doExport		  = false;
							bool nodoc			  = false;
							bool isDeprecated	  = false;
							bool isPrimitive	  = false;
							bool primitiveFloat	  = false;
							bool primitiveInPlace = false;
							primitiveOP op		  = primitiveOP::invalid;
							uint8_t access		  = 0;
							ABI* abi = defaultABI;
                            std::string symbol;
							for (token& attr : attribs) {
								if (attr.text == "local") isStatic = true;
								else if (attr.text == "public") access = 0;
								else if (attr.text == "protected") access = 1;
								else if (attr.text == "private") access = 2;
								else if (attr.text == "inline") isInline = true;
								else if (attr.text == "const") isConst = true;
								else if (attr.text == "extern") isExtern = true;
								else if (attr.text == "noop") isNoop = true;
                                else if (attr.text == "noreturn") isNoReturn = true;
								else if (attr.text == "nodoc") nodoc = true;
								else if (attr.text == "export") doExport = true;
								else if (attr.text == "deprecated")
									isDeprecated = true;
                                else if (attr.text.substr(0, strlen("SYMBOL-")) == "SYMBOL-") {
                                    //std::cout << "symbol: " << attr.text.substr(strlen("SYMBOL-"),attr.text.length()) << std::endl;
                                    symbol = attr.text.substr(strlen("SYMBOL-"),attr.text.length());
                                } else if (attr.text.substr(0, strlen("ABI-")) == "ABI-") {
									std::string ABIName =
										attr.text.substr(strlen("ABI-"),attr.text.length());
									abi = getABI(ABIName);
									if (abi == nullptr) {
                                        std::cout << "ERROR: ABI \""<< ABIName<< "\" does not exist!"<< std::endl;
									}
								} else if (attr.text.substr(0, strlen("mangling-")) == "mangling-") {
									std::string manglerName =
										attr.text.substr(strlen("mangling-"),
														 attr.text.length());
									mangling = getMangler(manglerName);
									if (mangling == nullptr) {
										std::cout << "ERROR: mangler \""
												  << manglerName
												  << "\" does not exist!"
												  << std::endl;
									}
								} else if (attr.text.substr(
											   0, strlen("primitive")) ==
										   "primitive") {
									isPrimitive = true;
									// primitives
									if (attr.text == "primitiveInPlace")
										primitiveInPlace = true;
									else if (attr.text == "primitiveFloat")
										primitiveFloat = true;
									else if (attr.text == "primitiveAdd")
										op = primitiveOP::add;
									else if (attr.text == "primitiveSub")
										op = primitiveOP::sub;
									else if (attr.text == "primitiveMul")
										op = primitiveOP::mul;
									else if (attr.text == "primitiveDiv")
										op = primitiveOP::div;
									else if (attr.text == "primitiveMod")
										op = primitiveOP::mod;
									else if (attr.text == "primitiveEqual")
										op = primitiveOP::equal;
									else if (attr.text == "primitiveNotEqual")
										op = primitiveOP::NotEqual;
									else if (attr.text == "primitiveGreater")
										op = primitiveOP::Greater;
									else if (attr.text == "primitiveGreaterEqual")
										op = primitiveOP::GreaterEqual;
									else if (attr.text == "primitiveLess")
										op = primitiveOP::Less;
									else if (attr.text == "primitiveLessEqual")
										op = primitiveOP::LessEqual;
									else if (attr.text == "primitiveAnd")
										op = primitiveOP::_and;
									else if (attr.text == "primitiveXor")
										op = primitiveOP::_xor;
									else if (attr.text == "primitiveOr")
										op = primitiveOP::_or;
									else if (attr.text == "primitiveNot")
										op = primitiveOP::Not;
									else if (attr.text == "primitiveInc")
										op = primitiveOP::Inc;
									else if (attr.text == "primitiveDec")
										op = primitiveOP::Dec;
									else if (attr.text == "primitiveAssign")
										op = primitiveOP::assign;
                                    else if (attr.text == "primitiveArrayIndex")
										op = primitiveOP::Index;
                                    else if (attr.text == "primitiveInterrupt")
										op = primitiveOP::Interrupt;
                                    else if (attr.text == "primitiveCPUID")
										op = primitiveOP::CPUid;
                                    else if (attr.text == "primitiveSYSCALL")
										op = primitiveOP::SYSCALL;
                                    else if (attr.text == "primitivePRINTCHAR")
										op = primitiveOP::PRINTCHAR;
                                    else if (attr.text == "primitivePRINTSTR")
										op = primitiveOP::PRINTSTR;
                                    else {
									    error::invalidFunctionAttribute(attr);
									    goto ERRORENDLINE;
								    }
								} else {
									error::invalidFunctionAttribute(attr);
									goto ERRORENDLINE;
								}
							}
							type* returnType = nullptr;
							std::vector<type*> paramTypes;
							std::vector<variable*> arguments;
							bool hasMoreParams = true;
							if (currentScope->t == scopeType::CLASS) {
								type* refType = getType(currentScope->cl->name + "&");
								paramTypes.push_back(refType);
								variable* targ = new variable;
								targ->dataType = refType;
								targ->name	   = "this";
								arguments.push_back(targ);
							}
                            t = L.nextToken();
							while (true) {
                                variable* arg = new variable;
                                arg->isParameter = true;
                                arg->__declared_file = currentFile;
                                arg->__declared_line = L.lineNum;
                                switch(t.type)
                                {
                                    case(42):
                                        t = L.nextToken();
                                        break;
                                    case(31):
                                        goto FUNCTIONNOARGS;
                                }
								switch (t.type) {
									case (9):
										returnType = getType(t.text);
										if (returnType->incomplete) {
											error::incompleteType(t);
											goto ERRORENDLINE;
										}
                                        arg->dataType = returnType;
										break;
                                    case(31):
                                        paramTypes.push_back(returnType);
                                        arguments.push_back(arg);
                                        goto FUNCTIONNOARGS;
                                        break;
									default:
										error::expectedTypename(t);
										goto ERRORENDLINE;
								}
                                t = L.nextToken();
                                switch (t.type) {
                                    case(1):
                                        arg->name = t.text;
                                        if(is_vstc_send)std::cout << "0004\x0c" << t.lineNum <<'\x0c'<< t.col <<'\x0c'<< t.text.length() <<'\x0c'<<t.text<<'\x0c'<<arg->__declared_file<<'\x0c'<<std::to_string(arg->__declared_line)<<'\x0c'<<arg->dataType->name<< '\n';
                                        t = L.nextToken();
                                        break;
                                    case(31):
                                        paramTypes.push_back(returnType);
                                        arguments.push_back(arg);
                                        goto FUNCTIONNOARGS;
                                        break;
                                    case(42):
                                        arg->name = getNewName();
                                        t = L.nextToken();
                                        break;
									default:
										error::expectedNewUnique(t);
										goto ERRORENDLINE;
								}
                                paramTypes.push_back(returnType);
                                arguments.push_back(arg);
							}
                            FUNCTIONNOARGS:;
							returnType = it;
							if (returnType->incomplete) {
								error::incompleteType(t);
								//goto ERRORENDLINE;
							}
							function* func		   = new function;
                            func->desc = currentd->desc;
                            func->returnDesc = currentd->ret;
                            func->__declared_file = currentFile;
                            func->__declared_line = L.lineNum;
							func->name			   = name;
							func->parameters	   = paramTypes;
							func->vparams		   = arguments;
                            for(variable* vp : func->vparams)
                            {
                                for(pdobj* o : currentd->params)
                                {
                                    if(o->name == vp->name)
                                    {
                                        vp->desc = o->desc;
                                    }
                                }
                            }
                            resetCurrentD();
							func->returnType	   = returnType;
							func->fstore		   = new functionStorage;
							func->isDeprecated	   = isDeprecated;
							func->isPrimitive	   = isPrimitive;
							func->primitiveFloat   = primitiveFloat;
							func->primitiveInPlace = primitiveInPlace;
							func->op			   = op;
                            func->noReturn         = isNoReturn;
							func->noDoc			   = nodoc;
							func->doExport		   = doExport;
                            func->abi = abi;
                            func->symbol = symbol;
                            func->isLocal = isStatic;
                            if(func->symbol.empty())
                            {
                                if(name == "main" && options::mainAutoSym)
                                    func->symbol = "cpe2main";
                                else
                                    mangling->mangle(func);
                            }
							//currentScope->functions.push_back(func);
                            globalScope->functions.push_back(func);
                            if(options::ddebug)
							    std::cout << "declared function: "<< getFunctionExpression(func, true) << std::endl;
                            t = L.nextToken();
							if (t.type == 40) {
								// indent based body
								scope* sc		  = new scope;
								sc->parent		  = currentScope;
								sc->name		  = func->symbol;
								sc->leadingSpace  = L.leadingSpaces + tabLength;
								sc->isIndentBased = true;
								sc->t			  = scopeType::FUNCTION;
								sc->fstore		  = func->fstore;
								sc->func		  = func;
								// declare variables for arguments
                                func->abi->setArgStorages(func,arguments);
								for (variable* arg : arguments) {
                                    sc->variables.push_back(arg);
                                    if(options::ddebug)
                                    {
                                        std::cout << "declared arg: " << arg->name << std::endl;
                                    }
									if (options::asmVerbose >= 2 || options::ddebug) {
										std::string comment = "    # " +
															  arg->name +
															  " is stored ";
										if (arg->storage ==
											storageType::MEMORY) {
											if (arg->offset < 0)
												comment += "at "+registerNAME(arg->reg);
											else 
                                                comment += "at "+registerNAME(arg->reg)+"+";
											comment += std::to_string(
												(int64_t)arg->offset);
										} else if (arg->storage ==
												   storageType::REGISTER) {
											comment +=
												"in " + registerNAME(arg->reg);
										} else if (arg->storage ==
												   storageType::
													   MEMORY_ABSOLUTE) {
											std::stringstream stream;
											stream << std::hex
												   << (int64_t)arg->offset;
											comment += "at 0x" + stream.str();
										}
                                        if(options::asmVerbose >= 2)
                                            sc->func->code.push_back(comment);
                                        if(options::ddebug)
                                            std::cout << comment << std::endl;
									}
								}
								updateCurrentScope(sc);
                                //debug info
                                if(true /*check for GAS (true for now)*/ && options::debugSymbols)
                                {
                                    setANB(16);
                                    //function.debug
                                    std::vector<std::string>* cc = code;
                                    code = &TextCode;
                                    placeSymbol(func->symbol+CPE2_SYMBOL_SCOPE_SEP"debug");
                                    code->push_back(getIndent()+".type "+func->symbol+", @function");
                                    code = cc;
                                    //.debug_info
                                    DebugCode.push_back(getIndent()+".uleb128 "+intToString(++dbgAbbrev));
                                    DebugCode.push_back(getIndent()+".string \""+func->name+"\"");
                                    DebugCode.push_back(getIndent()+".string \""+func->symbol+"\"");
                                    //.debug_abbrev
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString(dbgAbbrev));
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::TAG_subprogram));
                                    DebugAbbrevCode.push_back(getIndent()+".byte 1");//bool indicating the presence of child tags (0 for testing purposes)
                                    //mark main
                                    if(func->symbol == "cpe2main")
                                    {
                                        DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_main_subprogram));
                                        DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_flag_present));
                                    }
                                    if(!func->isLocal)
                                    {
                                        DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_external));
                                        DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_flag_present));
                                    }
                                    //name
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_name));
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_string));
                                    //symbol (linkage name)
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_linkage_name));
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_string));
                                    //terminator
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 0");
                                    DebugAbbrevCode.push_back(getIndent()+".uleb128 0");
                                    popANB();
                                }
								if (options::ddebug)
									std::cout << "body started" << std::endl;
							} else if (t.type == 41) {
								// function declaration
								if (!isPrimitive)
                                {
                                    if(!options::nod)
                                    {
                                        //optimizer data
                                        MiscCode.push_back("// @function "+func->symbol);
                                        for(variable* arg : func->vparams)
                                            MiscCode.push_back("// @parameter "+c2oLocExpr(arg));
                                        MiscCode.push_back("// @return rax");
                                        for(__register__ i : func->abi->VolatileRegisters)
                                            MiscCode.push_back("// @modifies "+registerNAME(i));
                                        for(__register__ i : func->abi->nonVolatile)
                                            MiscCode.push_back("// @preserves "+registerNAME(i));
                                        MiscCode.push_back(".extern " +
									    	func->symbol);
                                    }
                                }
								mOUT(1, func);
							} else {
                                errorCompilerBug;
                            }
						} else {
                            if(is_vstc_send)std::cout << "0002\x0c" << nametoken.lineNum <<'\x0c'<< nametoken.col <<'\x0c'<< nametoken.text.length() <<'\x0c'<<nametoken.text<<'\x0c'<<currentFile<<'\x0c'<<std::to_string(L.lineNum)<<'\x0c'<<it->name<<'\x0c'<<currentd->desc<<'\n';
							variable* var	  = new variable;
                            var->desc = currentd->desc;
                            resetCurrentD();
							var->dataType	  = it;
                            var->__declared_file = currentFile;
                            var->__declared_line = L.lineNum;
							mangler* mangling = defaultMangler;
							bool isStatic	  = false;
							bool isExtern	  = false;
							bool isConst	  = false;
                            bool isConstExpr  = false;
							bool isVolatile	  = false;
							bool noalloc	  = false;
							uint8_t access	  = 0;
                            token lspecToken;
							for (token& attr : attribs) {
								if (attr.text[0] == '(' &&
									attr.text.back() == ')') {
									// storage attribute
                                    lspecToken = attr;
									if (isdigit(attr.text[1])) {
										// absolute memory address
										token blub = t;
										blub.text  = attr.text.substr(
											 1, attr.text.size() - 2);
										uint64_t addr =
											resolve(blub)->immediateValue;
										var->storage =
											storageType::MEMORY_ABSOLUTE;
										var->offset = addr;
									} else if (attr.text[1] == '+' ||
											   attr.text[1] == '-') {
										// address relative to stack pointer
										token blub = t;
										blub.text  = attr.text.substr(
											 1, attr.text.size() - 2);
										uint64_t offset =
											resolve(blub)->immediateValue;
										var->storage = storageType::MEMORY;
										var->offset	 = offset;
                                        var->reg = StackPointer;
									} else {
										// register
										std::string rname = attr.text.substr(
											1, attr.text.size() - 2);
										__register__ reg = registerID(rname);
										if (reg == __register__::invalid)
											std::cout
												<< "invalid register name: "
												<< rname << std::endl;
										uint64_t rsize =
											BITMASK_REGISTER_SIZE & (uint64_t)reg;
                                        rsize>>=24;
										if (rsize < it->size) {
											std::cout
												<< "ERROR: register \"" << rname
												<< "\" is too small to fit "
												   "variable of type \""
												<< it->name << "\"!"
												<< std::endl;
										}
										var->storage = storageType::REGISTER;
										var->reg	 = reg;
									}
                                } else if (attr.text.substr(0, strlen("SYMBOL-")) == "SYMBOL-") {
                                    var->symbol = attr.text.substr(strlen("SYMBOL-"),attr.text.length());
								} else if (attr.text.substr(
											   0, strlen("mangling-")) ==
										   "mangling-") {
									std::string manglerName =
										attr.text.substr(strlen("mangling-"),
														 attr.text.length());
									mangling = getMangler(manglerName);
									if (mangling == nullptr) {
										std::cout << "ERROR: mangler \""
												  << manglerName
												  << "\" does not exist!"
												  << std::endl;
									}
								} else if (attr.text == "local")
									isStatic = true;
								else if (attr.text == "export")
									var->doExport = true;
								else if (attr.text == "public") access = 0;
								else if (attr.text == "protected") access = 1;
								else if (attr.text == "private") access = 2;
								else if (attr.text == "const") isConst = true;
                                else if (attr.text == "constexpr") isConstExpr = true;
								else if (attr.text == "extern") isExtern = true;
								else if (attr.text == "noalloc") noalloc = true;
								else if (attr.text == "volatile")
									isVolatile = true;
								else {
									error::invalidVariableAttribute(attr);
									goto ERRORENDLINE;
								}
							}
                            var->name	= name;
							var->access = access;
                            if(var->symbol.empty())
							    mangling->mangle(var);
                            if(isExtern)
                            {
                                var->storage = storageType::SYMBOL;
                                MiscCode.push_back(".extern " + var->symbol);
                            }
							if (var->storage == storageType::INVALID) {
								// auto storage
                                var->usedAutoStorage = true;
								if (currentScope->t == scopeType::FUNCTION || currentScope->t == scopeType::LOGICAL || currentScope->t == scopeType::CONDITIONAL_BLOCK)
								{
                                    currentScope->fstore->setStorage(currentScope->func,var);
                                }
								else if (currentScope->t == scopeType::CLASS) {
									var->offset	 = currentScope->cl->size;
									var->storage = storageType::MEMORY;
								}
							}
                            if(isArray)
                            {
                                if(currentScope->t == scopeType::FUNCTION  || currentScope->t == scopeType::LOGICAL || currentScope->t == scopeType::CONDITIONAL_BLOCK)
                                {
                                    uint64_t stackArrayBase = currentScope->fstore->stackOffset;
                                    currentScope->fstore->stackOffset+=(var->dataType->valueType->size*arraySizeCount);
                                    if(currentScope->fstore->stackOffset > currentScope->fstore->stackSize)
                                        currentScope->fstore->stackSize = currentScope->fstore->stackOffset;
                                    std::vector<variable*> eqArgs = {var,getImmediateVariable(stackArrayBase)};
                                    std::vector<variable*> addArgs = {var,getRegisterHandle(StackPointer)};
                                    call(getFunction("operator=",eqArgs),eqArgs);
                                    call(getFunction("operator+=",addArgs),addArgs);
                                }
                                else if(currentScope->t == scopeType::CLASS)
                                {
                                    uint64_t classArrayBase = currentScope->cl->size;
                                    currentScope->cl->size+=(var->dataType->valueType->size*arraySizeCount);
                                }
                            }
							if (options::asmVerbose >= 2 &&
								currentScope->t == scopeType::FUNCTION  || currentScope->t == scopeType::LOGICAL || currentScope->t == scopeType::CONDITIONAL_BLOCK) {
								std::string comment = getIndent() + "# " +
													  var->name + " is stored ";
								if (var->storage == storageType::MEMORY) {
									if (var->offset < 0) comment += "at "+registerNAME(var->reg);
									else comment += "at "+registerNAME(var->reg)+"+";
									comment +=
										std::to_string((int64_t)var->offset);
								} else if (var->storage ==
										   storageType::REGISTER) {
									comment += "in " + registerNAME(var->reg);
								} else if (var->storage ==
										   storageType::MEMORY_ABSOLUTE) {
									std::stringstream stream;
									stream << std::hex << (int64_t)var->offset;
									comment += "at 0x" + stream.str();
								}
								currentScope->func->code.push_back(comment);
							}
							if (currentScope->t == scopeType::FUNCTION || currentScope->t == scopeType::LOGICAL || currentScope->t == scopeType::CONDITIONAL_BLOCK) {
								if (var->storage == storageType::REGISTER)
									currentScope->fstore->registerStatus(
										var->reg, 1);
							}
							if (var->storage == storageType::REGISTER) {
                                //(uint64_t)var->reg & 0x504C532043554D20494E53494445204D45 /* UwU */
								if (((uint64_t)var->reg & BITMASK_REGISTER_CPL) < options::fcpl) {
                                    if(is_vsls_send)std::cout << "5001-" << lspecToken.lineNum <<'-'<< lspecToken.col+L.leadingSpaces <<'-'<< lspecToken.text.length() <<'-'<<lspecToken.text<<"-cpl-registers"<< '\n';
									else if (warn(getWarning("cpl-registers"), &L,
											 "insufficient privilege level to "
											 "access register \"" +
												 registerNAME(var->reg) +
												 "\"")) {
										note("required privilege level: " +
											 std::to_string((uint64_t)var->reg &
															0x000000FF00) +
											 " or lower.");
										note("current privilege level: " + std::to_string(options::fcpl));
										note("use --fcpl <some number> or \"#pragma cpl <some number>\" to set the privilege level.");
									}
								}
                                if(var->reg == StackPointer)
                                {
                                    if(is_vsls_send)std::cout << "5002-" << L.lineNum <<'-'<< lspecToken.col+L.leadingSpaces <<'-'<< lspecToken.text.length() <<'-'<<lspecToken.text<<"-stack-pointer-storage"<< '\n';
                                    else warn(getWarning("stack-pointer-storage"), &L, registerNAME(StackPointer)+" is currently used to store the stack pointer, you should not mess with the stack pointer unless you know what you're doing!");
                                }
							} else if (var->storage ==
									   storageType::MEMORY_ABSOLUTE) {
                                if(is_vsls_send)std::cout << "5003-" << lspecToken.lineNum <<'-'<< lspecToken.col+L.leadingSpaces <<'-'<< lspecToken.text.length() <<'-'<<"memory-absolute"<< '\n';
								else if (warn(getWarning("memory-absolute"), &L,
										 "saving variable at an absolute "
										 "memory address may be "
										 "unintentional"))
									note("use an explicit sign (+ or -) to "
										 "specifiy a stack-pointer-relative "
										 "address");
							}
							if (currentScope->t == scopeType::CLASS) {
                                if (var->storage == storageType::REGISTER) {
									// error register storage invalid for member
									// variables
									std::cout << "BLUB BLUB" << std::endl;
								} else {
									if (var->storage ==
											storageType::MEMORY_ABSOLUTE &&
										var->isStatic == false) {
										// error absolute address only legal for
										// local members
										std::cout << "BLUB" << std::endl;
									} else {
										currentScope->cl->members.push_back(
											*var);
										if (currentScope->cl->size <
											var->offset + var->dataType->size)
											currentScope->cl->size =
												var->offset +
												var->dataType->size;
									}
								}
                                if(options::ddebug)
                                    std::cout << "declared member: " << var->name << std::endl;
							} 
                            else
                            {
                                currentScope->variables.push_back(var);
                                bool isPointer = var->dataType->name.back() == '*' ? true : false;
                                type* childTargetDataType = isPointer ? var->dataType->valueType : var->dataType;
                                //std::cout << "vdt: " << std::hex << (void*)var->dataType << std::endl;
                                //std::cout << "vdtvt: " << std::hex << (void*)var->dataType->valueType << std::endl;
                                //std::cout << "isPointer: " << isPointer << std::endl;
                                //std::cout << "ctdt: " << std::hex << (void*)childTargetDataType << std::endl;
                                if(childTargetDataType->members.size() > 0)
                                {
                                    if(var->storage == storageType::REGISTER && !isPointer)
                                    {
                                        if(var->usedAutoStorage)
                                        {
                                            //switch to memory storage
                                            std::cout << "switching storage of: " << var->name << std::endl;
                                            errorCompilerBug;
                                        }
                                        else
                                            std::cout << "ERROR: dont do that" << std::endl;
                                    }
                                    else
                                    {
                                        std::string msep = isPointer ? "->" : ".";
                                        if(isPointer)
                                        {
                                            for(variable i : childTargetDataType->members)
                                            {
                                                //init
                                                variable* child = new variable(i);
                                                child->doExport = false;
                                                //name
                                                child->name = var->name+msep+child->name;
                                                //storage
                                                child->storage = storageType::MEMORY;
                                                child->reg = var->reg;
                                                //finish up
                                                child->parent = var;
                                                var->children.push_back(child);
                                                currentScope->variables.push_back(child);
                                                if(options::ddebug)
                                                    std::cout << "declared child: " << child->name << std::endl;
                                            }
                                        }
                                        else
                                        {
                                            for(variable i : childTargetDataType->members)
                                            {
                                                //init
                                                variable* child = new variable(i);
                                                child->doExport = false;
                                                //name
                                                child->name = var->name+msep+child->name;
                                                //storage
                                                child->reg = var->reg;
                                                child->offset += var->offset;
                                                //finish up
                                                child->parent = var;
                                                var->children.push_back(child);
                                                currentScope->variables.push_back(child);
                                                if(options::ddebug)
                                                    std::cout << "declared child: " << child->name << std::endl;
                                            }
                                        }
                                    }
                                }
                            }
                            if(options::ddebug)
                                std::cout << "declared variable: " << var->name << std::endl;
                            //debug
                            if(true /*check for GAS (true for now)*/ && options::debugSymbols)
                            {setANB(16);
                                //
                                //.debug_info
                                //
                                DebugCode.push_back(getIndent()+".uleb128 "+intToString(++dbgAbbrev));
                                DebugCode.push_back(getIndent()+".string \""+var->name+"\"");
                                DebugCode.push_back(getIndent()+".string \""+var->symbol+"\"");
                                DebugCode.push_back(getIndent()+".quad "+intToString(var->dataType->dwarfID));
                                //
                                //.debug_abbrev
                                //
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString(dbgAbbrev));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::TAG_variable));
                                DebugAbbrevCode.push_back(getIndent()+".byte 0");//no children
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_name));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_string));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_linkage_name));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_string));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_external));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_flag_present));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::AT_type));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 "+intToString((uint64_t)DWARF5::FORM_ref8));
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 0");//terminate
                                DebugAbbrevCode.push_back(getIndent()+".uleb128 0");
                            popANB();}
                            //docs
							mOUT(moVariableID, var);
							t = L.nextToken();
							switch (t.type) {
								case (3): // operator
								{
									line tmpLine = L;
									tmpLine.stripTokens(attribs.size() + 1);
									std::vector<line> tmpLines;
									tmpLines.push_back(tmpLine);
                                    isConstExprAssignment = isConstExpr;
									parse(tmpLines);
                                    isConstExprAssignment = false;
									break;
								}
                                case(6):
                                case(7):
                                case(11):
								case (1):
									variable* result = resolve(t);
                                    if(!result)
                                    {
                                        error::noSuchIdentifier(t);
                                        goto ERRORENDLINE;
                                    }
                                    std::vector<variable*> args;
                                    args.push_back(var);
                                    args.push_back(result);
                                    function* func = getFunction("operator=", args);
							        if (func != nullptr) {
                                        if(isConstExpr)
                                        {
                                            var->storage = storageType::IMMEDIATE;
                                            var->immediateValue = result->immediateValue;
                                            //std::cout << "assigned \""<<result->immediateValue<<"\" to constexpr \""<<var->name <<"\""<< std::endl;
                                        }
                                        else
                                        {
							        	    if (func->isDeprecated)
							        	    	warn(getWarning("deprecated"), &L,
							        	    		 "call to deprecated function \"" +
							        	    			 func->name + "\"");
							        	    call(func, args);
                                        }
							        }
                                    else
                                        error::functionNotFound(L);
									break;
							}
                            if(currentScope->t == scopeType::GLOBAL || currentScope->t == scopeType::NAMESPACE)
                            {
                                if(var->storage == storageType::SYMBOL && !isExtern)
                                    MiscCode.push_back(".global " + var->symbol);
                                else if(var->storage == storageType::INVALID)
                                {
                                    var->storage = storageType::SYMBOL;
                                    DataCode.push_back(var->symbol+":");
                                    switch(var->dataType->size)
                                    {
                                        case(1):
                                            DataCode.push_back("\t.byte 0");
                                            break;
                                        case(2):
                                            DataCode.push_back("\t.word 0");
                                            break;
                                        case(4):
                                            DataCode.push_back("\t.int 0");
                                            break;
                                        case(8):
                                            DataCode.push_back("\t.quad 0");
                                            break;
                                    }
                                    //MiscCode.push_back(".global " + var->symbol);
                                }
                            }
						}

						break;
					}
					case (10): {
						// do smth with variable
						break;
					}
					case (11): {
						// function call
						break;
					}
				}
				break;
			case (10): {
				// do smth with variable
				//std::string name = t.text;
                //if(options::ddebug)
                //    info("var name: "+name);
                //std::vector<variable*> args__;
				//variable* arg1	 = getVariable(t.text);
				//t				 = L.nextToken();
                //if(t.type == 32)
                //{
                //    t = L.nextToken();
                //    line indexLine = L;
                //    indexLine.tpos = 0;
                //    indexLine.text = "";
                //    while(t.type != 33)
                //    {
                //        indexLine.text += t.text;
                //        t = L.nextToken();
                //    }
                //    token indexToken = indexLine.nextToken();
                //    variable* index = resolve(indexToken);
                //    //
                //    std::string fname = "operator[]";
                //    args__.push_back(arg1);
                //    args__.push_back(index);
                //    function* indexOP = getFunction(fname,args__);
                //    if(indexOP)
                //        arg1 = call(indexOP,args__);
                //    else
                //        error::functionNotFound(L);
                //    //
                //    t = L.nextToken();
                //}
				//switch (t.type) {
                //    case(34):
                //        t = L.nextToken();
                //        if(t.type == 34)
                //            t.text = "<<";
                //        else
                //            break;
                //        goto procop;
				//	case (3):
                //        procop:;
                //        std::string functionName;
				//		std::string op = t.text;
				//		if (t.text == "=") functionName = "operator" + t.text;
				//		else if (t.text == "+=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "-=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "*=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "/=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "%=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "==")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "|=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "&=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "^=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "!=")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "*")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "+")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "-")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "/")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "++")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "--")
				//			functionName = "operator" + t.text;
				//		else if (t.text == "^")
				//			functionName = "operator" + t.text;
                //        else if (t.text == "<<")
				//			functionName = "operator" + t.text;
                //        else if (t.text == ">>")
				//			functionName = "operator" + t.text;
				//		else {
                //            if(functionName == "")
				//			{
                //                std::cout << "unknown operator: " << t.text<< std::endl;
                //            }
				//		}
				//		t = L.nextToken();
                //        if(options::asmVerbose >= 3)
                //            if(currentScope->func != nullptr)
				//		        currentScope->func->code.push_back(getIndent() + "# " + L.text);
				//		variable* arg2 = resolve(t);
				//		if (arg2 == nullptr) {
				//			std::cout << "wtf?" << std::endl;
                //            printLine(L);
				//		} else {
				//			std::vector<variable*> args;
				//			args.push_back(arg1);
				//			if (op != "++" && op != "--") args.push_back(arg2);
				//			function* func = getFunction(functionName, args);
				//			if (func != nullptr) {
				//				if (func->isDeprecated)
				//					warn(getWarning("deprecated"), &L,
				//						 "call to deprecated function \"" +
				//							 func->name + "\"");
				//				call(func, args);
				//			}
                //            else
                //                error::functionNotFound(L);
				//		}
                //        break;
				//}
                if(isConstExprAssignment)
                    std::cout << "assigning constexpr" << std::endl;
                resolve(t);
				break;
			}
			case (11): {
				// function call
                variable* result = resolve(t);
				break;
			}
			case (1): {
				// new unique identifier
				if (currentScope->t == scopeType::ENUM) {
					// declare new local enum member
				}
				break;
			}
			default:
                std::cout << "blub blub bug" << std::endl;
                printToken(t);
				std::cout << "line: " << L.text << std::endl;
		}
	ERRORENDLINE:;
    ENDLINE:;
		if (++i >= lines.size()) break;
	}
    ENDPARSER:;
    dbgFile.pop();
    templateMode = 0;//cant ever be too sure in a file exceeding 2.000 lines LMFAO
}
